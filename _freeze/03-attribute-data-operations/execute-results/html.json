{
  "hash": "5d13df61b2e4c6b07e45966d8db53cbb",
  "result": {
    "engine": "knitr",
    "markdown": "# Attribute data operations {#sec-chap03}\n\n\n\n\n\n\n\n\n\n\n\n\n## Introduction\n\nAttribute data is non-spatial information associated with geographic (geometry) data. This chapter teaches how to manipulate geographic objects based on attributes such as the names of bus stops in a vector dataset and elevations of pixels in a raster dataset.\n\n## Vector attribute manipulation\n\nGeographic vector datasets are well supported in R thanks to the {**sf**} class, which extends base R’s `data.frame`. Like data frames, `sf` objects have one column per attribute variable (such as ‘name’) and one row per observation or feature (e.g., per bus station). {**sf**} provides generics that allow `sf` objects to behave like regular data frames.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-sf-methods}\n: Methods for `sf` objects\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::library(sf) |> base::suppressPackageStartupMessages()\nutils::methods(class = \"sf\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] [                            [[<-                        \n#>  [3] [<-                          $<-                         \n#>  [5] aggregate                    as.data.frame               \n#>  [7] cbind                        coerce                      \n#>  [9] dbDataType                   dbWriteTable                \n#> [11] duplicated                   identify                    \n#> [13] initialize                   merge                       \n#> [15] plot                         points                      \n#> [17] print                        rbind                       \n#> [19] show                         slotsFromS3                 \n#> [21] st_agr                       st_agr<-                    \n#> [23] st_area                      st_as_s2                    \n#> [25] st_as_sf                     st_as_sfc                   \n#> [27] st_bbox                      st_boundary                 \n#> [29] st_break_antimeridian        st_buffer                   \n#> [31] st_cast                      st_centroid                 \n#> [33] st_collection_extract        st_concave_hull             \n#> [35] st_convex_hull               st_coordinates              \n#> [37] st_crop                      st_crs                      \n#> [39] st_crs<-                     st_difference               \n#> [41] st_drop_geometry             st_exterior_ring            \n#> [43] st_filter                    st_geometry                 \n#> [45] st_geometry<-                st_inscribed_circle         \n#> [47] st_interpolate_aw            st_intersection             \n#> [49] st_intersects                st_is_full                  \n#> [51] st_is_valid                  st_is                       \n#> [53] st_join                      st_line_merge               \n#> [55] st_m_range                   st_make_valid               \n#> [57] st_minimum_rotated_rectangle st_nearest_points           \n#> [59] st_node                      st_normalize                \n#> [61] st_point_on_surface          st_polygonize               \n#> [63] st_precision                 st_reverse                  \n#> [65] st_sample                    st_segmentize               \n#> [67] st_set_precision             st_shift_longitude          \n#> [69] st_simplify                  st_snap                     \n#> [71] st_sym_difference            st_transform                \n#> [73] st_triangulate_constrained   st_triangulate              \n#> [75] st_union                     st_voronoi                  \n#> [77] st_wrap_dateline             st_write                    \n#> [79] st_z_range                   st_zm                       \n#> [81] text                         transform                   \n#> see '?methods' for accessing help and source code\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::detach(\"package:sf\", unload = TRUE)\n```\n:::\n\n\n\n\n\n***\n\nMany of the generic methods (those not starting with `st_`) like `aggregate()`, `cbind()`, `merge()`, `rbind()` and `]` are for manipulating data frames. \n\n- `rbind()`, for example, binds rows of data frames together, one ‘on top’ of the other. \n- `$<-` creates new columns.\n::::\n:::::\n\n**A key feature of `sf` objects is that they store spatial and non-spatial data in the same way, as columns in a `data.frame`.**\n\n\n`sf` objects can also extend the {**tidyverse**} classes for data frames, `tbl_df` and `tbl`. Thus {**sf**} enables the full power of R’s data analysis capabilities to be unleashed on geographic data, whether you use base R or tidyverse functions for data analysis.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-sf-vector-properties}\n: Basic properties of vector data objects\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### With geometry\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-sf-properties-with-geometry}\n: Basic properties of a `sf` object with geometry column\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"world\", package = \"spData\")\nbase::class(world)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::dim(world)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 177  11\n```\n\n\n:::\n\n```{.r .cell-code}\nskimr::skim(world)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: Couldn't find skimmers for class: sfc_MULTIPOLYGON, sfc; No\n#> user-defined `sfl` provided. Falling back to `character`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n\nTable: Data summary\n\n|                         |      |\n|:------------------------|:-----|\n|Name                     |world |\n|Number of rows           |177   |\n|Number of columns        |11    |\n|_______________________  |      |\n|Column type frequency:   |      |\n|character                |7     |\n|numeric                  |4     |\n|________________________ |      |\n|Group variables          |None  |\n\n\n**Variable type: character**\n\n|skim_variable | n_missing| complete_rate| min|   max| empty| n_unique| whitespace|\n|:-------------|---------:|-------------:|---:|-----:|-----:|--------:|----------:|\n|iso_a2        |         2|          0.99|   2|     2|     0|      175|          0|\n|name_long     |         0|          1.00|   4|    35|     0|      177|          0|\n|continent     |         0|          1.00|   4|    23|     0|        8|          0|\n|region_un     |         0|          1.00|   4|    23|     0|        7|          0|\n|subregion     |         0|          1.00|   9|    25|     0|       22|          0|\n|type          |         0|          1.00|   7|    17|     0|        5|          0|\n|geom          |         0|          1.00| 135| 24760|     0|      177|          0|\n\n\n**Variable type: numeric**\n\n|skim_variable | n_missing| complete_rate|        mean|           sd|       p0|        p25|         p50|         p75|         p100|hist  |\n|:-------------|---------:|-------------:|-----------:|------------:|--------:|----------:|-----------:|-----------:|------------:|:-----|\n|area_km2      |         0|          1.00|   832558.33|   2163425.48|  2416.87|   46185.25|   185004.13|   621860.35| 1.701851e+07|▇▁▁▁▁ |\n|pop           |        10|          0.94| 42815798.06| 149413217.06| 56295.00| 3754725.00| 10401062.00| 30748039.00| 1.364270e+09|▇▁▁▁▁ |\n|lifeExp       |        10|          0.94|       70.85|         8.21|    50.62|      64.96|       72.87|       76.78| 8.359000e+01|▂▃▅▇▅ |\n|gdpPercap     |        17|          0.90|    17105.99|     18668.07|   597.14|    3752.37|    10734.07|    24232.74| 1.208601e+05|▇▂▁▁▁ |\n\n\n:::\n:::\n\n\n\n\n\n::::\n:::::\n\n\n###### Without geometry\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-property-without-geometry}\n: Properties of a `sf` object withput geometry column\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_df = sf::st_drop_geometry(world)\nbase::class(world_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::dim(world_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 177  10\n```\n\n\n:::\n\n```{.r .cell-code}\ndplyr::glimpse(world_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 177\n#> Columns: 10\n#> $ iso_a2    <chr> \"FJ\", \"TZ\", \"EH\", \"CA\", \"US\", \"KZ\", \"UZ\", \"PG\", \"ID\", \"AR\", …\n#> $ name_long <chr> \"Fiji\", \"Tanzania\", \"Western Sahara\", \"Canada\", \"United Stat…\n#> $ continent <chr> \"Oceania\", \"Africa\", \"Africa\", \"North America\", \"North Ameri…\n#> $ region_un <chr> \"Oceania\", \"Africa\", \"Africa\", \"Americas\", \"Americas\", \"Asia…\n#> $ subregion <chr> \"Melanesia\", \"Eastern Africa\", \"Northern Africa\", \"Northern …\n#> $ type      <chr> \"Sovereign country\", \"Sovereign country\", \"Indeterminate\", \"…\n#> $ area_km2  <dbl> 19289.97, 932745.79, 96270.60, 10036042.98, 9510743.74, 2729…\n#> $ pop       <dbl> 885806, 52234869, NA, 35535348, 318622525, 17288285, 3075770…\n#> $ lifeExp   <dbl> 69.96000, 64.16300, NA, 81.95305, 78.84146, 71.62000, 71.039…\n#> $ gdpPercap <dbl> 8222.2538, 2402.0994, NA, 43079.1425, 51921.9846, 23587.3375…\n```\n\n\n:::\n\n```{.r .cell-code}\nskimr::skim(world_df)\n```\n\n::: {.cell-output-display}\n\nTable: Data summary\n\n|                         |         |\n|:------------------------|:--------|\n|Name                     |world_df |\n|Number of rows           |177      |\n|Number of columns        |10       |\n|_______________________  |         |\n|Column type frequency:   |         |\n|character                |6        |\n|numeric                  |4        |\n|________________________ |         |\n|Group variables          |None     |\n\n\n**Variable type: character**\n\n|skim_variable | n_missing| complete_rate| min| max| empty| n_unique| whitespace|\n|:-------------|---------:|-------------:|---:|---:|-----:|--------:|----------:|\n|iso_a2        |         2|          0.99|   2|   2|     0|      175|          0|\n|name_long     |         0|          1.00|   4|  35|     0|      177|          0|\n|continent     |         0|          1.00|   4|  23|     0|        8|          0|\n|region_un     |         0|          1.00|   4|  23|     0|        7|          0|\n|subregion     |         0|          1.00|   9|  25|     0|       22|          0|\n|type          |         0|          1.00|   7|  17|     0|        5|          0|\n\n\n**Variable type: numeric**\n\n|skim_variable | n_missing| complete_rate|        mean|           sd|       p0|        p25|         p50|         p75|         p100|hist  |\n|:-------------|---------:|-------------:|-----------:|------------:|--------:|----------:|-----------:|-----------:|------------:|:-----|\n|area_km2      |         0|          1.00|   832558.33|   2163425.48|  2416.87|   46185.25|   185004.13|   621860.35| 1.701851e+07|▇▁▁▁▁ |\n|pop           |        10|          0.94| 42815798.06| 149413217.06| 56295.00| 3754725.00| 10401062.00| 30748039.00| 1.364270e+09|▇▁▁▁▁ |\n|lifeExp       |        10|          0.94|       70.85|         8.21|    50.62|      64.96|       72.87|       76.78| 8.359000e+01|▂▃▅▇▅ |\n|gdpPercap     |        17|          0.90|    17105.99|     18668.07|   597.14|    3752.37|    10734.07|    24232.74| 1.208601e+05|▇▂▁▁▁ |\n\n\n:::\n:::\n\n\n\n\n\n::::\n:::::\n\n`world` contains ten non-geographic columns (and one geometry list column) with 177 rows representing the world’s countries. The function `sf::st_drop_geometry()` keeps only the attributes data of an `sf` object, in other words removing its geometry and convert it to a \"normal\" data.frame.\n\nYou can see that `skimr::skim()` reproduces a warning just in the first case. `dplyr::glimpse()` would produce an error, but both listings work in the second case without problems.\n\n:::\n\n::::\n:::::\n\n::: {.callout-note #nte-03-different-geometry-column-names}\n###### Different names of the geometry column\n\nThe geometry column of `sf` objects is typically called \"geometry\" or \"geom\", but any name can be used. The following command, for example, creates a geometry column named g:\n\n`sf::st_sf(base::data.frame(n = world$name_long), g = world$geom)`\n\nThis enables geometries imported from spatial databases to have a variety of names such as \"wkb_geometry\" and \"the_geom\".\n:::\n\n\n\nDropping the geometry column before working with attribute data can be useful; data manipulation processes can run faster when they work only on the attribute data and geometry columns are not always needed. For most cases, however, it makes sense to keep the geometry column, explaining why the column is ‘sticky’ (it remains after most attribute operations unless specifically dropped). Non-spatial data operations on sf objects only change an object’s geometry when appropriate (e.g., by dissolving borders between adjacent polygons following aggregation). \n\n**Becoming skilled at geographic attribute data manipulation means becoming skilled at manipulating data frames.**\n\n\n:::::{.my-remark}\n:::{.my-remark-header}\n:::::: {#rem-03-sf-tidyverse-pitfalls}\n: {**sf**} has tidyverse compatibility with some pitfalls\n::::::\n:::\n::::{.my-remark-container}\nFor many applications, the tidyverse package {**dplyr**} (see Package Profile @sec-96-dplyr) offers an effective approach for working with data frames. Tidyverse compatibility is an advantage of {**sf**} over its predecessor {**sp**}, but there are some [pitfalls to avoid](https://geocompx.github.io/geocompkg/articles/tidyverse-pitfalls.html).\n\nI have already experience with {**dplyr**} data wrangling. If there is no difference using `sf` objects or `\"tbl_df` resp. `tbl` objects, I may not include these passages into this notebook.\n::::\n:::::\n\n### Vector attribute subsetting (empty)\n\n[skipped](https://r.geocompx.org/attr#vector-attribute-subsetting)\n\n### Chaining commands with pipes (empty)\n\n[skipped](https://r.geocompx.org/attr#chaining-commands-with-pipes)\n\n### Vector attribute aggregation (empty)\n\n[skipped](https://r.geocompx.org/attr#vector-attribute-aggregation)\n\n### Vector attribute joining (empty)\n\n[skipped](https://r.geocompx.org/attr#vector-attribute-joining)\n\n### Creating attributes and removing spatial information (empty)\n\n[skipped](https://r.geocompx.org/attr#vec-attr-creation)\n\n## Manipulating raster objects\n\nThis section shows how raster objects work by creating them from scratch, building on Section @sec-02-intro-terra. Because of their unique structure, subsetting and other operations on raster datasets work in a different way.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-create-raster-object-from-scratch}\n: Creating raster objects from scratch\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### numerical\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-create-numerical-raster}\n: Creating raster object with numerical data\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = terra::rast(nrows = 6, ncols = 6,\n            xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n            vals = 1:36)\nelev\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> class       : SpatRaster \n#> dimensions  : 6, 6, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.5, 0.5  (x, y)\n#> extent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 \n#> source(s)   : memory\n#> name        : lyr.1 \n#> min value   :     1 \n#> max value   :    36\n```\n\n\n:::\n:::\n\n\n\n\n\n***\n\nThe result is a raster object with 6 rows and 6 columns (specified by the nrow and ncol arguments), and a minimum and maximum spatial extent in x and y direction (xmin, xmax, ymin, ymax). The vals argument sets the values that each cell contains: numeric data ranging from 1 to 36 in this case.\n\n\n::::\n:::::\n\n\n\n###### categorical\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-create-categorical-raster}\n: Creating raster object with categorical data\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrain_order = base::c(\"clay\", \"silt\", \"sand\")\ngrain_char = base::sample(grain_order, 36, replace = TRUE)\ngrain_fact = base::factor(grain_char, levels = grain_order)\ngrain = terra::rast(nrows = 6, ncols = 6, \n             xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n             vals = grain_fact)\n\ngrain\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> class       : SpatRaster \n#> dimensions  : 6, 6, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.5, 0.5  (x, y)\n#> extent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 \n#> source(s)   : memory\n#> categories  : label \n#> name        : lyr.1 \n#> min value   :  clay \n#> max value   :  sand\n```\n\n\n:::\n:::\n\n\n\n\n\n::::\n:::::\n\n:::\n\n::: {.callout-note #nte-03-stored-raster-objects}\n`elev` and `grain` are the same raster objects as stored in {**spData**} as `elev.tif` respectively as `grain.tif`.   \n\nThis is helpful as I do not need to save or wrap/unwrap these objects for use in later chunk. Just loading via `<name> = terra::rast(base::system.file(\"raster/<name>.tif\", package = \"spData\"))` is enough.\n:::\n\n::::\n:::::\n\nThe raster object stores the corresponding look-up table or “Raster Attribute Table” (RAT) as a list of data frames, which can be viewed with `terra::cats(grain)`. Each element of this list is a layer of the raster. It is also possible to use the function terra::levels() for retrieving and adding new or replacing existing factor levels.\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-raster-attribute-table}\n: Raster Attribute Table (RAT)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrain2 = terra::rast(base::system.file(\"raster/grain.tif\", package = \"spData\"))\nlevels(grain2) = data.frame(value = c(0, 1, 2), wetness = c(\"wet\", \"moist\", \"dry\"))\nterra::cats(grain2)\nterra::levels(grain2)\nterra::identical(terra::cats(grain2), terra::levels(grain2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [[1]]\n#>   value wetness\n#> 1     0     wet\n#> 2     1   moist\n#> 3     2     dry\n#> \n#> [[1]]\n#>   value wetness\n#> 1     0     wet\n#> 2     1   moist\n#> 3     2     dry\n#> \n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n::::\n:::::\n\nCategorical raster objects can also store information about the colors associated with each value using a color table. The color table is a data frame with three (red, green, blue) or four (alpha) columns, where each row relates to one value. Color tables in {**terra**} can be viewed or set with the `terra::coltab()` function. Importantly, saving a raster object with a color table to a file (e.g., GeoTIFF) will also save the color information.\n\nThe following figure simulates book's Figure 3.2.. There are some differences such as that the legend is outside the graphic and in a different format.\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-plot-rasters}\n: Plot numerical and categorical raster object\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = terra::rast(base::system.file(\"raster/elev.tif\", package = \"spData\"))\n\ngrain <- terra::rast(base::system.file(\"raster/grain.tif\", package = \"spData\"))\ngrain2 <-  grain \nlevels(grain2) <- data.frame(value = c(0, 1, 2), wetness = c(\"clay\", \"silt\", \"sand\"))\ncol_df <- data.frame(value = 0:2, col = c(clay = \"#a52a2a\", silt = \"#f4a460\", sand = \"#bc8f8f\"))\nterra::coltab(grain2) <- col_df\n\npar(mfrow = c(1, 2))\nterra::plot(elev, col = terra::map.pal(\"blues\"))\nterra::plot(grain2)\n```\n\n::: {.cell-output-display}\n![Raster datasets with numeric (left) and categorical values (right).](03-attribute-data-operations_files/figure-html/fig-plot-rasters-1.png){#fig-plot-rasters width=672}\n:::\n:::\n\n\n\n\n\n::::\n:::::\n\n### Raster subsetting\n\n:::::{.my-remark}\n:::{.my-remark-header}\n:::::: {#rem-03-tidyterra}\n: Numbered Remark Title\n::::::\n:::\n::::{.my-remark-container}\nAs learning about raster data (und therefore {**terra**}) is not my main focuse I will not go into details in this section. See also @rem-02-terra-use-cases.\n::::\n:::::\n\n\nRaster subsetting in the book is done with the base R operator `[`, which accepts a variety of inputs. \n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-03-tidyterra}\n: New package {**tidyterra**}\n::::::\n:::\n::::{.my-resource-container}\nThere is the new package {**tidyterra**} which provide common methods of the {**tidyverse**} packages for objects created with the {**terra**} package: `SpatRaster` and `SpatVector`. It also provides `geoms` for plotting these objects with {**ggplot2**}.\n::::\n:::::\n\n\nFrom the four possible inputs for raster data, that is\n\n- row-column indexing,\n- cell IDs,\n- coordinates, and\n- another spatial object\n\nonly the first two options can be considered non-spatial operations. (For subestting spatial operations see @XXXSection4-3-1.)\n\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-raster-subsetting-single-layer}\n: Raster single layer subsetting with base R and {**tidyterra**}\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### base R\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-base-r-raster-subsetting}\n: Raster subsetting with base R operator `[`\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = terra::rast(base::system.file(\"raster/elev.tif\", package = \"spData\"))\n\nelev[1, 1] # row 1, column 1\nelev[1] # cell ID 1\nelev[2, 1] # row 2, column 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   elev\n#> 1    1\n#>   elev\n#> 1    1\n#>   elev\n#> 1    7\n```\n\n\n:::\n:::\n\n\n\n\n\n::::\n:::::\n\n\n###### {**tidyterra**}\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-tidyterra-raster-subsetting}\n: Raster subsetting with {**tidyterra**}\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = terra::rast(base::system.file(\"raster/elev.tif\", package = \"spData\"))\n\nelev |> \n    tidyterra::slice_rows(2) |> \n    tidyterra::slice_cols(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> class       : SpatRaster \n#> dimensions  : 1, 1, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.5, 0.5  (x, y)\n#> extent      : -1.5, -1, 0.5, 1  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source(s)   : memory\n#> varname     : elev \n#> name        : elev \n#> min value   :    7 \n#> max value   :    7\n```\n\n\n:::\n\n```{.r .cell-code}\nelev |> \n    tidyterra::slice_colrows(\n        rows = 2,\n        cols = 1\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> class       : SpatRaster \n#> dimensions  : 1, 1, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.5, 0.5  (x, y)\n#> extent      : -1.5, -1, 0.5, 1  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source(s)   : memory\n#> varname     : elev \n#> name        : elev \n#> min value   :    7 \n#> max value   :    7\n```\n\n\n:::\n:::\n\n\n\n\n\n***\n\n{**tidyterra**} applies many {**dplyr**} commands to {**terra**}. The above two subsettng commands are specialized functios adapted to the raster format that are provided with {**tidyterra**} in addition to the standard {**dplyr**} functions: `slice()`, `slice_head()`, `slice_tail()`, `slice_min()`, `slice_max()`, and `slice_sample()`.\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\nSubsetting of multi-layered raster objects will return the cell value(s) for each layer. For example, two_layers = c(grain, elev); two_layers[1] returns a data frame with one row and two columns — one for each layer. To extract all values, you can also use values().\n\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-03-raster-subsetting-multiple-layer}\n: Subsetting of multi-layered raster objects\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### base R\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-03-multi-layer-base-r-raster-subsetting}\n: Subsetting of multi-layered raster objects\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = terra::rast(base::system.file(\"raster/elev.tif\", package = \"spData\"))\ngrain = terra::rast(base::system.file(\"raster/grain.tif\", package = \"spData\"))\n\ntwo_layers <- c(grain, elev) \ntwo_layers[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   grain elev\n#> 1  silt    1\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(terra::values(two_layers)) # show first six values of all layers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      grain elev\n#> [1,]     1    1\n#> [2,]     0    2\n#> [3,]     1    3\n#> [4,]     2    4\n#> [5,]     2    5\n#> [6,]     2    6\n```\n\n\n:::\n\n```{.r .cell-code}\ntwo_layers |> \n    tidyterra::slice_colrows(\n        rows = 1,\n        cols = 1\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> class       : SpatRaster \n#> dimensions  : 1, 1, 2  (nrow, ncol, nlyr)\n#> resolution  : 0.5, 0.5  (x, y)\n#> extent      : -1.5, -1, 1, 1.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source(s)   : memory\n#> varname     : grain \n#> names       : grain, elev \n#> min values  :  silt,    1 \n#> max values  :  silt,    1\n```\n\n\n:::\n\n```{.r .cell-code}\ntwo_layers |> \n    tidyterra::slice_head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> class       : SpatRaster \n#> dimensions  : 1, 1, 2  (nrow, ncol, nlyr)\n#> resolution  : 0.5, 0.5  (x, y)\n#> extent      : -1.5, -1, 1, 1.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source(s)   : memory\n#> varname     : grain \n#> names       : grain, elev \n#> min values  :  silt,    1 \n#> max values  :  silt,    1\n```\n\n\n:::\n:::\n\n\n\n\n\n::::\n:::::\n\n\n###### header2\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-code-name-b}\n: Numbered R Code Title (Tidyverse)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelev = terra::rast(base::system.file(\"raster/elev.tif\", package = \"spData\"))\ngrain = terra::rast(base::system.file(\"raster/grain.tif\", package = \"spData\"))\n\ntwo_layers <- c(grain, elev) |> \n```\n:::\n\n\n\n\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}