{
  "hash": "6299a2139e8ab3141167cce46e123535",
  "result": {
    "engine": "knitr",
    "markdown": "# Geographic Data in R {#sec-chap02}\n\n\n\n\n\n\n\n## Introduction\n\nThis chapter will provide explanations of the fundamental geographic\ndata models: vector and raster.\n\n-   **Vector**: The vector data model represents the world using points,\n    lines and polygons. These have discrete, well-defined borders.\n    Vector data tends to dominate the social sciences because human\n    settlements tend to have discrete borders.\n-   **Raster**: The raster data model divides the surface up into cells\n    of constant size. Raster datasets are the basis of background images\n    used in web mapping. Raster dominates many environmental sciences\n    partially because of the reliance on remote sensing data.\n\n## Vector Data\n\nThe geographic vector data model is based on points located within a\ncoordinate reference system (<a class='glossary' title='A Coordinate Reference System (CRS) defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a>). Points can represent\nself-standing features (e.g., the location of a bus stop) or they can be\nlinked together to form more complex geometries such as lines and\npolygons.\n\nThe {**sf**} package provides classes for geographic vector data and a\nconsistent command line interface to important low-level libraries for\ngeocomputation:\n\n-   <a class='glossary' title='The Geospatial Data Abstraction Library (GDAL) is a computer software library for reading and writing raster and vector geospatial data formats (e.g. shapefile), and is released under the permissive X/MIT style free software license by the Open Source Geospatial Foundation. As a library, it presents a single abstract data model to the calling application for all supported formats. (Wikipedia)'>GDAL</a>, for reading, writing and manipulating a wide\n    range of geographic data formats, covered in [@XXXChapter8]. See:\n    [GDAL](https://gdal.org/en/stable/) [@rouault-2025].\n-   <a class='glossary' title='PROJ is a generic coordinate transformation software that transforms geospatial coordinates from one coordinate reference system (CRS) to another. This includes cartographic projections as well as geodetic transformations. PROJ is released under the X/MIT open source license.'>PROJ</a>, a powerful library for coordinate system\n    transformations, which underlies the content covered in\n    [@XXXChapter7]. See: [PROJ](https://proj.org/en/stable/)\n    [@evenden-2024].\n-   <a class='glossary' title='GEOS (Graphical Environment Operating System) is a C/C++ library for computational geometry with a focus on algorithms used in geographic information systems (GIS) software. It implements the OGC Simple Features geometry model and provides all the spatial functions in that standard as well as many others. GEOS is open source software available under the terms of GNU Lesser General Public License (LGPL).'>GEOS</a>, a planar geometry engine for operations such\n    as calculating buffers and centroids on data with a projected\n    <a class='glossary' title='A Coordinate Reference System (CRS) defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a>, covered in [@XXXChapter5]. See\n    [GEOS](https://libgeos.org/) [@geoscontributors-2024].\n-   <a class='glossary' title='S2 is a spherical geometry engine written in C++ developed by Google. Unlike traditional geographic information systems, which represent data as flat two-dimensional projections (similar to an atlas), the S2 library represents all data on a three-dimensional sphere (similar to a globe).'>S2</a>, a spherical geometry engine written in C++\n    developed by Google, via the {**s2**} package, covered in @sec-02-s2\n    and in @XXXChapter7. See: [S2](http://s2geometry.io/)\n    [@s2-geometry-contributors-2025].\n\nInformation about these interfaces is printed by {**sf**} the first time\nthe package is loaded. The message tells us the versions of linked GEOS,\nGDAL and PROJ libraries (these vary between computers and over time) and\nwhether or not the S2 interface is turned on. --- Since {**sf**} version\n1.0.0, launched in June 2021, [s2 functionality is now used by\ndefault](https://r-spatial.org/r/2020/06/17/s2.html) on geometries with\ngeographic (longitude/latitude) coordinate systems.\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-loaded-interfaces}\n: Print message about interfaces by loading {**sf**}\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::library(sf) # attach package\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::detach(\"package:sf\", unload=TRUE) ## return previous status\n```\n:::\n\n\n:::\n::::::\n\nA neat feature of {**sf**} is that you can change the default geometry\nengine used on unprojected data: ‘switching off’ S2 can be done with the\ncommand `sf::sf_use_s2(FALSE)`, meaning that the planar geometry engine\nGEOS will be used by default for all geometry operations, including\ngeometry operations on unprojected data.\n\n### Introduction to simple features\n\n<a class='glossary' title='Simple Features, officially known as Simple Feature Access (ISO 19125), is a set of standards that specify a common storage and access model for geographic features, primarily composed of two-dimensional geometries like points, lines, polygons, and others. These standards are formalized by both the Open Geospatial Consortium (OGC) and the International Organization for Standardization (ISO). Simple features is a hierarchical data model that represents a wide range of geometry types. Of 18 geometry types supported by the specification, only seven are used in the vast majority of geographic research: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION.'>Simple features</a> is a hierarchical data model that\nrepresents a wide range of geometry types. Of 18 geometry types\nsupported by the specification, only seven are used in the vast majority\nof geographic research (see @fig-02-sf-classes); these core geometry\ntypes are fully supported by the R package {**sf**}.\n\n------------------------------------------------------------------------\n\n![Simple feature types fully supported by\n{sf}.](img/02-sf-classes-border-min.png){#fig-02-sf-classes\nfig-alt=\"The picture shows a square surrounded by six other squares. Three of the squares contain a geometric object titled POINT, LINESTRING, and POLYGON. Three other squares contain two identical geometric objects titles MULTIOPOINT, MULTILINESTRING, AND MULTIPOLYGON. All these six squares have a connection to the centered square called GEOMETRYCOLLECTION containing all the different objects of the six peripheral squares.\"\nfig-align=\"center\" width=\"70%\"}\n\n------------------------------------------------------------------------\n\n{**sf**} provides the same functionality (and more) previously provided\nin three (now deprecated) packages:\n\n-   {**sp**} for data classes\n-   {**rgdal**} for data read/write via an interface to GDAL and PROJ\n    and\n-   {**rgeos**} for spatial operations via an interface to GEOS.\n\n::: {#nte-02-dprecated-packages .callout-note}\n###### Deprecated packages & the history of the R-spatial ecosystem\n\nThis detailed infos (together with the history of the R-spatial\necosystem provided in Chapter 1 of the book) I would have needed\nearlier. When I started to learn spatial data science (one month ago,\nDecember 2024) I was confused about the many different packages with\nsimilar functionality.\n:::\n\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-02-sf-documentation}\n: {**sf**} documentation\n::::::\n:::\n::::{.my-resource-container}\nsf’s functionality is well documented on its website at\n[r-spatial.github.io/sf/](https://r-spatial.github.io/sf/) which contains [seven\nvignettes](https://r-spatial.github.io/sf/articles/).\n\n1. [Simple Features for R](https://r-spatial.github.io/sf/articles/sf1.html)\n2. [Reading, Writing and Converting Simple Features](https://r-spatial.github.io/sf/articles/sf2.html)\n3. [Manipulating Simple Feature Geometries](https://r-spatial.github.io/sf/articles/sf3.html)\n4. [Manipulating Simple Features](https://r-spatial.github.io/sf/articles/sf4.html)\n5. [Plotting Simple Features](https://r-spatial.github.io/sf/articles/sf5.html)\n6. [Miscellaneous](https://r-spatial.github.io/sf/articles/sf6.html)\n7. [Spherical geometry in sf using s2geometry](https://r-spatial.github.io/sf/articles/sf1.html)\n::::\n:::::\n\n\n**Simple feature objects in R are stored in a data frame, with geographic\ndata occupying a special column, usually named ‘geom’ or ‘geometry’.\nSimple features are, in essence, data frames with a spatial extension.**\n\n:::::::::::::::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-02-inspect-sf-classes}\n: Inspect {**sf**} classes, plotting, summary, and subsetting\n:::\n:::::\n\n:::::::::::::::::::::::: my-code-collection-container\n::::::::::::::::::::::: panel-tabset\n###### Inspect data\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-inspect-sf-world-data}\n: Inspect class and column names of `world`\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"world\", package = \"spData\")\nbase::class(world)\nbase::names(world)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n#>  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n#>  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nThe contents of the `geom` column give {**sf**} objects their spatial\npowers: `world$geom` is a ‘list column’ that contains all the\ncoordinates of the country polygons.\n:::\n::::::\n\n###### Plot data\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-plot-sf-world-data}\n: Plot `world` data\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf:::plot.sf(world) # plot produces only the first 9 attributes (1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: plotting the first 9 out of 10 attributes; use max.plot = 10 to plot\n#> all\n```\n\n\n:::\n\n```{.r .cell-code}\nsf:::plot.sf(world, max.plot = 10) # 11 cols but 'geom' does not count as attribute (2)\nsf:::plot.sf(world, max.plot = Inf) # plot all availabe attributes (3)\n```\n\n::: {.cell-output-display}\n![Map of the world using the {**sf**} package, with a facet for each attribute.](02-geographic-data_files/figure-html/fig-02-plot-sf-world-data-1.png){#fig-02-plot-sf-world-data-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Map of the world using the {**sf**} package, with a facet for each attribute.](02-geographic-data_files/figure-html/fig-02-plot-sf-world-data-2.png){#fig-02-plot-sf-world-data-2 width=672}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nInstead of creating a single map by default for geographic objects, as\nmost GIS programs do, `plot()`ing `sf` objects results in a map for each\nvariable in the datasets. This behavior can be useful for exploring the\nspatial distribution of different variables.\n\nIf you attach the {**sf**} package with `library(sf)` then `plot(world)`\nwould have worked. But it is not the `base::plot()` function as errors\nin line 2 and 3 would show. `plot()` is a generic function that is\nextended by other packages. {**sf**} contains the non-exported (hidden\nfrom users most of the time and therefore with three columns prefixed)\n`sf:::plot.sf()` function which is called behind the scenes.\n:::\n::::::\n\n###### Summary\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-summary}\n: Treating sf objects as data frames\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::summary(world[\"lifeExp\"]) # infos about the 'geom' column \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     lifeExp                 geom    \n#>  Min.   :50.62   MULTIPOLYGON :177  \n#>  1st Qu.:64.96   epsg:4326    :  0  \n#>  Median :72.87   +proj=long...:  0  \n#>  Mean   :70.85                      \n#>  3rd Qu.:76.78                      \n#>  Max.   :83.59                      \n#>  NA's   :10\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::summary(world$lifeExp) # no infos about the 'geom' column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n#>   50.62   64.96   72.87   70.85   76.78   83.59      10\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nTreating geographic objects as regular data frames with spatial powers\nhas many advantages, especially if you are already used to working with\ndata frames. The commonly used `summary()` function, for example,\nprovides a useful overview of the variables within the world object.\n:::\n::::::\n\n###### Subsetting\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-subsetting}\n: Subsetting `sf` object with base R and {dplyr}\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld[1:2, 1:3] # base R subsetting\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.28799 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#>   iso_a2 name_long continent                           geom\n#> 1     FJ      Fiji   Oceania MULTIPOLYGON (((-180 -16.55...\n#> 2     TZ  Tanzania    Africa MULTIPOLYGON (((33.90371 -0...\n```\n\n\n:::\n\n```{.r .cell-code}\nworld |> # tidyverse subsetting\n    dplyr::slice(1:2) |>\n    dplyr::select(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.28799 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 2 × 4\n#>   iso_a2 name_long continent                                                geom\n#>   <chr>  <chr>     <chr>                                      <MULTIPOLYGON [°]>\n#> 1 FJ     Fiji      Oceania   (((-180 -16.55522, -179.9174 -16.50178, -179.7933 …\n#> 2 TZ     Tanzania  Africa    (((33.90371 -0.95, 31.86617 -1.02736, 30.76986 -1.…\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nSubsetting is another example where `sf` objects are treating as normal\ndata frames. The output shows two major differences compared with a\nregular data.frame:\n\n-   the inclusion of additional geographic metadata (Geometry type,\n    Dimension, Bounding box and coordinate reference system\n    information), and\n-   the presence of a ‘geometry column’, here named \"geom\".\n\nBase R and tidyverse subsetting yield the same result, but with slightly\ndifferent formatting of the 'geom' column.\n:::\n::::::\n\n###### Class of 'geom' column\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-geom-class}\n: Class of the 'geom' column and of one entry of the 'geom' column\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::class(world) # class of sf object (sf)\nbase::class(world$geom) # class of 'geom' column (sfc)\nbase::class(world$geom[[1]]) # class of first entry of 'geom' (sfg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n#> [1] \"sfc_MULTIPOLYGON\" \"sfc\"             \n#> [1] \"XY\"           \"MULTIPOLYGON\" \"sfg\"\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nHere you can see the hierarchy of the three object types in the {**sf**}\nuniverse. I explain it in reverse order, starting with the lowest level:\n\n-   **sfg (Simple Feature Gemometry)** is the lowest unit; it has only\n    coordinates (according to the [well-known\n    text](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry)\n    (<a class='glossary' title='Well-known text (WKT) is a text markup language for representing vector geometry objects in spatial analysis. WKT is used to mark geometric objects together to signify the same attribute, such as combining multiple points to represent a single entity like a university campus.'>WKT</a>) standard)\n-   **sfc (Simple Feature Gemometry Collection)** is a set of sfg's,\n    plus - crucially! - information about interpretation of the\n    coordinate reference system / are the coordinates in meters, or\n    degrees? plane or sphere? if sphere, which one? this is highly\n    standardized stuff, often described in terms of <a class='glossary' title='EPSG stands for European Petroleum Survey Group, which is now known as the Geomatics Committee of the International Association of Oil and Gas Producers (IOGP). This organization maintains a database of coordinate system information, including datums, projections, and transformations, which is widely used in geographic information systems (GIS) for identifying and transforming coordinate reference systems. The EPSG Geodetic Parameter Dataset (https://epsg.org/) is available as a free download and serves as a global resource for coordinate system and transformation information.'>EPSG</a>\n    codes ([EPSG Geodetic Parameter\n    Dataset](https://epsg.org/home.html)).\n-   **sf (Simple Feature)** is a sfc geometry with data columns, in\n    addition to the geometry.\n:::\n::::::\n:::::::::::::::::::::::\n::::::::::::::::::::::::\n::::::::::::::::::::::::::::\n\n### Why simple features?\n\nSimple features is a widely supported data model that underlies data\nstructures in many <a class='glossary' title='GIS stands for Geographic Information System, which is a computer system designed to capture, store, manage, analyze, and display all types of geographical data. It allows users to visualize and analyze location-based data, helping organizations make informed decisions by identifying patterns and relationships in spatial data. GIS technology includes hardware, software, and data, and it often involves human users, procedures, and workflows to effectively manage and utilize geographic information.'>GIS</a> applications including\n[QGIS](https://qgis.org/) and [PostGIS](https://postgis.net/).\n\nThere are numerous advantages using the {**sf**} package:\n\n-   Fast reading and writing of data\n-   Enhanced plotting performance\n-   `sf` objects can be treated as data frames in most operations\n-   `sf` function names are relatively consistent and intuitive (all\n    begin with `st_`)\n-   `sf` functions can be combined with the \\|\\> operator and works well\n    with the {**tidyverse**} collection of R packages.\n\n`sf::st_read()` vs. `sf::read_sf()` are good examples to show and\ncompare the support for the {**tidyverse**} pckages.\n\n-   `sf::st_read()` emits verbose messages and returns the file content\n    stored in a base R `data.frame`.\n-   `sf::read_sf()` silently returns data as a tidyverse `tibble`.\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-compare-df-tib}\n: Compare `sf::st_read()` with `sf::read_sf()`\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_dfr = sf::st_read(system.file(\"shapes/world.gpkg\", package = \"spData\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Reading layer `world' from data source \n#>   `/Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/library/spData/shapes/world.gpkg' \n#>   using driver `GPKG'\n#> Simple feature collection with 177 features and 10 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\n#> Geodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\nworld_tbl = sf::read_sf(system.file(\"shapes/world.gpkg\", package = \"spData\"))\nbase::class(world_dfr) # base data.frame\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::class(world_tbl) # tidyverse tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nData files from the {**spData**} package are located in the folder\n\"shapes\" inside the {**spData**} package folder.This can be detected\nmanually in the operating systems by opening the folder \"spData\" for the\n{**spData**} package. To get the file path one has to use the\n`base::system.file()` function with the appropriate package name and\nproviding the path to the file inside this package:\n`system.file(\"shapes/world.gpkg\", package = \"spData\")`.\n:::\n::::::\n\n::: {#nte-importance-sf .callout-note}\n###### {**sf**} is now the go-to package for analysis of spatial vector data in R\n\n{**spatstat**}, a package ecosystem which provides numerous functions\nfor spatial statistics, and {**terra**} both have vector geographic data\nclasses, but neither has the same level of uptake as {**sf**} does for\nworking with vector data. Many popular packages build on {**sf**}.\n:::\n\n### Basic Maps\n\n:::::::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-02-sf-basic-maps}\n: Basic maps created with {sf}\n:::\n:::::\n\n:::::::::::::::: my-code-collection-container\n::::::::::::::: panel-tabset\n###### Multi-panel plot\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-multi-panel-plot}\n: Multi-panel plot with {sf}\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf:::plot.sf(world[3:6])\n```\n\n::: {.cell-output-display}\n![A multi-panel plot with {**sf**} creates one sub-plot for each variable of the object.](02-geographic-data_files/figure-html/fig-02-sf-multi-panel-plot-1.png){#fig-02-sf-multi-panel-plot width=672}\n:::\n:::\n\n\n:::\n::::::\n\n###### Single plot\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-single-plot}\n: Single plot with {sf}\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf:::plot.sf(world[\"pop\"])\n```\n\n::: {.cell-output-display}\n![If the object to be plotted with {sf} has a single variable, then a legend with a continuous color is produced.](02-geographic-data_files/figure-html/fig-02-sf-single-plot-1.png){#fig-02-sf-single-plot width=672}\n:::\n:::\n\n\n:::\n::::::\n\n###### Fixed colors\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-fixed-color-plot}\n: Plot with {sf} with fixed country and border colors\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf:::plot.sf(world[\"pop\"], col = \"lightblue\", border = \"black\")\n```\n\n::: {.cell-output-display}\n![You can set fixed colors in the `sf::plot.sf()` commands with `col` and `border` arguments.](02-geographic-data_files/figure-html/fig-02-sf-fixed-color-plot-1.png){#fig-02-sf-fixed-color-plot width=672}\n:::\n:::\n\n\n:::\n::::::\n:::::::::::::::\n::::::::::::::::\n::::::::::::::::::::\n\nThere are various ways to modify maps with {**sf**}’s plot() method.\nBecause {**sf**} extends base R plotting methods, `graphics::plot()`’s\narguments work with {**sf**} objects (see `?graphics::plot` and `?par`\nfor information on arguments.)\n\n:::::::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-02-sf-adding-plot-layers}\n: Adding different layers to plot output of `sf` objects\n:::\n:::::\n\n:::::::::::::::: my-code-collection-container\n::::::::::::::: panel-tabset\n###### filters & combining\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-filter-and-combine}\n: Numbered R Code Title\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"world\", package = \"spData\") # get world data\n\nbase::library(sf) |> base::suppressPackageStartupMessages() # load {sf}\n\nasia <-  world |> \n    dplyr::filter(continent == \"Asia\") |> # (1)\n    sf::st_union()\n\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, add = TRUE, col = \"red\")\n\ndetach(\"package:sf\", unload = TRUE) # return to previous state, unload {sf}\n```\n\n::: {.cell-output-display}\n![Plot of Asia added as a layer on top of countries worldwide.](02-geographic-data_files/figure-html/fig-02-sf-filter-and-combine-1.png){#fig-02-sf-filter-and-combine width=672}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nPlots are added as layers to existing images by setting `add = TRUE`.\nLine (1) in the above code chunk filters countries in Asia and combines\nthem in line (2) into a single feature.\n\nWe can now plot the Asian continent over a map of the world. Note that\nthe first plot (line (3)) must only have one facet for `add = TRUE` to\nwork. If the first plot has a key (legend), `reset = FALSE` must be\nused.\n:::\n::::::\n\n###### unprojected\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-overlay-circles-unprojected}\n: Overlay circles representing country population on a world map\n(unprojected version)\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::library(sf) |> base::suppressPackageStartupMessages() # load {sf}\n\nplot(world[\"continent\"], reset = FALSE)                    # (1)\ncex = base::sqrt(world$pop) / 10000                        # (2)\nworld_cents = sf::st_centroid(world, of_largest = TRUE)    # (3)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: st_centroid assumes attributes are constant over geometries\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(sf::st_geometry(world_cents), add = TRUE, cex = cex)  # (4)\n\ndetach(\"package:sf\", unload = TRUE) # return to previous state, unload {sf}\n```\n\n::: {.cell-output-display}\n![Overlaying circles, whose diameters (set with `cex =`) represent country populations, on a map of the world. Unprojected version](02-geographic-data_files/figure-html/fig-02-sf-overlay-circles-unprojected-1.png){#fig-02-sf-overlay-circles-unprojected width=672}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nThe code above uses the function `sf::st_centroid()` to convert one\ngeometry type (polygons) to another (points) (see @XXXChapter5), the\naesthetics of which are varied with the `cex` argument.\n\nThe `sf::st_centroid()` function (line 3) produced: *'Warning:\nst_centroid assumes attributes are constant over geometries'*.\n\n> \"The reason for this is that the dataset contains variables with\n> values that are associated with entire polygons … meaning they are not\n> associated with a POINT geometry replacing the polygon.\"\n> [@pebesma-2023, chapter 5]\n:::\n::::::\n\n###### projected\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-overlay-circles-projected}\n: Overlay circles representing country population on a world map\n(projected version)\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"world\", package = \"spData\")\n\nbase::library(sf) |> base::suppressPackageStartupMessages() # load {sf}\n\nworld_proj = sf::st_transform(world, \"+proj=eck4\")                                   # (1)\nworld_cents = sf::st_centroid(world_proj, of_largest_polygon = TRUE)                 # (2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: st_centroid assumes attributes are constant over geometries\n```\n\n\n:::\n\n```{.r .cell-code}\ngraphics::par(mar = c(0, 0, 0, 0))                                                   # (3)\nplot(world_proj[\"continent\"], reset = FALSE, main = \"\", key.pos = NULL)              # (4)\ng = sf::st_graticule()                                                               # (5)\ng = sf::st_transform(g, crs = \"+proj=eck4\")                                          # (6)\nplot(g$geometry, add = TRUE, col = \"lightgray\")                                      # (7)\ncex = base::sqrt(world$pop) / 10000                                                  # (8)\nplot(sf::st_geometry(world_cents), add = TRUE, cex = cex, lwd = 2, graticule = TRUE) # (9)\n\ndetach(\"package:sf\", unload = TRUE) # return to previous state, unload {sf}\n```\n\n::: {.cell-output-display}\n![Overlaying circles, whose diameters (set with `cex =`) represent country populations, on a map of the world. Projected version](02-geographic-data_files/figure-html/fig-02-sf-overlay-circles-projected-1.png){#fig-02-sf-overlay-circles-projected width=672}\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nFor the above code I used the [script\n02-contplot.R](https://github.com/geocompx/geocompr/blob/main/code/02-contpop.R).\nThere are new code lines to change the unprojected to a projected figure\nthat I do not yet understand fully.\n:::\n::::::\n:::::::::::::::\n\nIn all code chunks of this code collection I had to attach {**sf**}\nbecause the `sf:plot.sf(`) commands did not work. I received the error\nmessage '*Error in if (ncol(x) == 1) { : argument is of length zero*'.\nAfter changing the original code of the function to\n`if (isTRUE(x) && ncol(x) == 1)` I received other errors. Finally I gave\nup and used the standard `base::library(sf)`.\n::::::::::::::::\n::::::::::::::::::::\n\n{**sf**}’s plot method also has arguments specific to geographic data.\n`expandBB`, for example, can be used to plot an `sf` object in context:\nit takes a numeric vector of length four that expands the bounding box\nof the plot relative to zero in the following order: bottom, left, top,\nright. This is used in the following code to plot India in the context\nof its giant Asian neighbors, with an emphasis on China to the east.\n\n:::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-02-using-expandBB}\n: Using `expandBB` argument to plot an `sf` object in context\n:::\n:::::\n\n:::::::::::: my-code-collection-container\n::::::::::: panel-tabset\n###### no labels\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-plot-expandBB-no-labels}\n: Creating context by plotting with the `expandBB` argument (without\nlabels)\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::library(sf) |> base::suppressPackageStartupMessages() # load {sf}\n\nindia <- world |> \n    dplyr::filter(name_long == \"India\")\nworld_asia <- world |> \n    dplyr::filter(continent == \"Asia\")\n\nplot(sf::st_geometry(india), expandBB = c(-0.2, 0.5, 0, 1), col = \"gray\", lwd = 3)\nplot(sf::st_geometry(world_asia), add = TRUE)\n\ndetach(\"package:sf\", unload = TRUE) # return to previous state, unload {sf}\n```\n\n::: {.cell-output-display}\n![India in context, demonstrating the `expandBB` argument (without labels).](02-geographic-data_files/figure-html/fig-02-sf-plot-expandBB-no-labels-1.png){#fig-02-sf-plot-expandBB-no-labels width=672}\n:::\n:::\n\n\n:::\n::::::\n\n###### with labels\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-plot-expandBB-with-labels}\n: Creating context by plotting with the `expandBB` argument (with\nlabels)\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"world\", package = \"spData\")\nbase::library(sf) |> base::suppressPackageStartupMessages() # load {sf}\n\nindia <- world |> \n    dplyr::filter(name_long == \"India\")\nworld_asia <- world |> \n    dplyr::filter(continent == \"Asia\")\nindchi  <-  \n    world_asia[grepl(\"Indi|Chi\", world_asia$name_long), ]\nindchi_coords <- \n    sf::st_centroid(indchi) |> \n    sf::st_coordinates()\n\nold_par = graphics::par(mar = rep(0, 4))\n\nplot(sf::st_geometry(india), expandBB = c(-0.2, 0.5, 0, 1), col = \"gray\", lwd = 3)\nplot(world_asia[0], add = TRUE)\nterra::text(indchi_coords[, 1], indchi_coords[, 2], indchi$name_long)\n\ngraphics::par(old_par)\n\ndetach(\"package:sf\", unload = TRUE) # return to previous state, unload {sf}\n```\n\n::: {.cell-output-display}\n![India in context, demonstrating the `expandBB` argument (with labels).](02-geographic-data_files/figure-html/fig-02-sf-plot-expandBB-with-labels-1.png){#fig-02-sf-plot-expandBB-with-labels width=672}\n:::\n:::\n\n\n:::\n::::::\n:::::::::::\n\nNote the use of `lwd` (linewidth) to emphasize India in the plotting\ncode. See @XXXChapter9-2 for other visualization techniques for\nrepresenting a range of geometry types, the subject of the next section.\n::::::::::::\n::::::::::::::::\n\n### Geometry types\n\nGenerally, well-known binary (<a class='glossary' title='Well-known binary (WKB) is a format for representing geographical and geometrical data in a binary form. It is designed to be platform-independent and is typically used for transporting geometry data between systems or programs. WKB uses 1-byte unsigned integers, 4-byte unsigned integers, and 8-byte double-precision numbers (IEEE 754 format).'>WKB</a>) or well-known text\n(<a class='glossary' title='Well-known text (WKT) is a text markup language for representing vector geometry objects in spatial analysis. WKT is used to mark geometric objects together to signify the same attribute, such as combining multiple points to represent a single entity like a university campus.'>WKT</a>) are the standard encoding for simple feature\ngeometries.\n\n-   **WKB** representations are usually hexadecimal strings easily\n    readable for computers. This is why GIS and spatial databases use\n    WKB to transfer and store geometry objects.\n-   **WKT**, on the other hand, is a human-readable text markup\n    description of simple features. Both formats are exchangeable.\n\n### The sf class\n\nSimple features consist of two main parts: geometries and non-geographic\nattributes. @fig-02-sf-diagram shows how an `sf` object is created –\ngeometries come from an `sfc` object, while attributes are taken from a\n`data.fram`e or `tibble`.\n\n![Building blocks of `sf`\nobjects](img/02-sf-diagram-border-min.png){#fig-02-sf-diagram\nfig-alt=\"alt-text\" fig-align=\"center\" width=\"100%\"}\n\nMore about building sf geometries from scratch see @sec-02-sf-sfg and\n@sec-02-sf-sfc.\n\n:::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-02-sf-builing-blocks}\n: Creation and Class of sf Building Blocks\n:::\n:::::\n\n:::::::::::: my-code-collection-container\n::::::::::: panel-tabset\n###### Creation\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-building-block-creation}\n: Building blocks of `sf` objects\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(lnd_point = sf::st_point(c(0.1, 51.5))   )              # (1) sfg object\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT (0.1 51.5)\n```\n\n\n:::\n\n```{.r .cell-code}\n(lnd_geom = sf::st_sfc(lnd_point, crs = \"EPSG:4326\"))    # (2) sfc object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Geometry set for 1 feature \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 0.1 ymin: 51.5 xmax: 0.1 ymax: 51.5\n#> Geodetic CRS:  WGS 84\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT (0.1 51.5)\n```\n\n\n:::\n\n```{.r .cell-code}\n(\n    lnd_attrib = base::data.frame(                       # (3) data.frame object\n      name = \"London\",\n      temperature = 25,\n      date = base::as.Date(\"2023-06-21\")\n    )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     name temperature       date\n#> 1 London          25 2023-06-21\n```\n\n\n:::\n\n```{.r .cell-code}\n(lnd_sf = sf::st_sf(lnd_attrib, geometry = lnd_geom))    # (4) sf object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Simple feature collection with 1 feature and 3 fields\n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 0.1 ymin: 51.5 xmax: 0.1 ymax: 51.5\n#> Geodetic CRS:  WGS 84\n#>     name temperature       date         geometry\n#> 1 London          25 2023-06-21 POINT (0.1 51.5)\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n-   **Line 1**: The coordinates were used to create the simple feature\n    geometry (sfg).\n-   **Line 2**: The geometry was converted into a simple feature\n    geometry column (sfc), with a <a class='glossary' title='A Coordinate Reference System (CRS) defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a>.\n-   **Line 3**: Attributes were stored in a data.frame.\n-   **Line 4**: The data.frame was combined with the sfc object. The\n    results in an sf object.\n\nThe result shows that `sf` objects actually have two classes, `sf` and\n`data.frame`. Simple features are simply data frames (square tables),\nbut with spatial attributes stored in a list column, usually called\ngeometry or geom. This duality is\ncentral to the concept of simple features: most of the time a `sf` can\nbe treated as and behaves like a data.frame. **Simple features are, in\nessence, data frames with a spatial extension.**\n:::\n::::::\n\n###### Classes\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sf-classes}\n: Classes of sf Building Blocks\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::class(lnd_point)  # sfg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"XY\"    \"POINT\" \"sfg\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::class(lnd_geom)   # sfc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sfc_POINT\" \"sfc\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::class(lnd_attrib) # data.frame\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::class(lnd_sf)     # sf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nDepending of the created geometry type POINT can be replaced by\nLINESTRING, POLYGON, MUTLIPOINT, MULTILINESTRING, MULTIPOLYGON. It is\nmost often the case that the objects are of identical type. In case of a\nmix of types or an empty set, POINT (or any of the other mentioned\ngemoetries) are set to the superclass GEOMETRY.\n:::\n::::::\n:::::::::::\n::::::::::::\n::::::::::::::::\n\n@fig-02-building-blocks-sf shows --- as a kind of summary --- the\ndifferent `sf` objects in their contexts [Picture taken from\n@sadler-2018].\n\n![Building Blocks of sf\nobjects](img/02-sf-building-blocks-border-min.jpg){#fig-02-building-blocks-sf\nfig-alt=\"alt-text\" style=\"border: 0px solid black; padding: 5px;\"\nfig-align=\"center\" width=\"100%\"}\n\n### Simple feature geometries (sfg) {#sec-02-sf-sfg}\n\nThe <a class='glossary' title='Simple Feature Geometry (SFG) is a fundamental concept in the sf package for R, used for representing the geometry of a single spatial feature. SFG objects can represent various types of geometries, such as points, lines, and polygons. These geometries are encoded using well-known binary (WKB) or well-known text (WKT) formats, which are human-readable representations of the geometries. SFG objects are implemented as native R data structures, such as vectors, matrices, or lists of matrices, depending on the geometry type. They consist of three classes corresponding to the dimensions, geometry type, and the SFG class itself. Additionally, SFG objects possess coordinates, which can be represented as a vector or a matrix.'>sfg</a> class represents the different simple feature\ngeometry types in R: point, linestring, polygon (and their ‘multi’\nequivalents, such as multipoints) or geometry collection.\n\nUsually you are spared the tedious task of creating geometries on your\nown since you can simply import an already existing spatial file.\nHowever, there are a set of functions to create simple feature geometry\nobjects (sfg) from scratch, if needed. The names of these functions are\nsimple and consistent, as they all start with the `st_` prefix and end\nwith the name of the geometry type in lowercase letters:\n\n-   A point: `sf::st_point()`\n-   A linestring: `sf::st_linestring()`\n-   A polygon: `sf::st_polygon()`\n-   A multipoint: `sf::st_multipoint()`\n-   A multilinestring: `sf::st_multilinestring()`\n-   A multipolygon: `sf::st_multipolygon()`\n-   A geometry collection: `sf::st_geometrycollection()`\n\nsfg objects can be created from three base R data types:\n\n-   **Numeric vector**: a single point\n-   **Matrix**: a set of points, where each row represents a point, a\n    multipoint or linestring\n-   **List**: a collection of objects such as matrices, multilinestrings\n    or geometry collections.\n\n:::::::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-02-creating-sfg}\n: Creating Simple Feature Geometries (sfg)\n:::\n:::::\n\n:::::::::::::::: my-code-collection-container\n::::::::::::::: panel-tabset\n###### Numeric Vectors\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-create-single-points}\n: Create single points from numerical vectors\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf::st_point(base::c(5, 2))                 # XY point\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT (5 2)\n```\n\n\n:::\n\n```{.r .cell-code}\nsf::st_point(base::c(5, 2, 3))              # XYZ point\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT Z (5 2 3)\n```\n\n\n:::\n\n```{.r .cell-code}\nsf::st_point(base::c(5, 2, 1), dim = \"XYM\") # XYM point\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT M (5 2 1)\n```\n\n\n:::\n\n```{.r .cell-code}\nsf::st_point(base::c(5, 2, 3, 1))           # XYZM point\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT ZM (5 2 3 1)\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\n\"XYZ\" refers to coordinates where the third dimension represents\naltitude, \"XYM\" refers to three-dimensional coordinates where the third\ndimension refers to something else (\"M\" for measure).\n\nThe results show that XY (2D coordinates), XYZ (3D coordinates, Z =\naltitude) and XYZM (3D with an additional variable, typically\nmeasurement accuracy, M = measurement) point types are created from\nvectors of lengths 2, 3, and 4, respectively. The XYM type must be\nspecified using the `dim` argument (which is short for dimension).\n:::\n::::::\n\n###### Matrices\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-create-multipoint-linestring}\n: Create multipoint and linestring from matrices\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmultipoint_matrix = base::rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\nsf::st_multipoint(multipoint_matrix) ## MULTIPOINT\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> MULTIPOINT ((5 2), (1 3), (3 4), (3 2))\n```\n\n\n:::\n\n```{.r .cell-code}\nlinestring_matrix = base::rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))\nsf::st_linestring(linestring_matrix) ## LINESTRING\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nThe `base::rbind()` function simplifies the creation of matrices.\n\nI have `base::` not prefixed to `c()`.\n:::\n::::::\n\n###### Lists\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-create-from-lists}\n: Create polygons from lists\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## POLYGON\npolygon_list = base::list(base::rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\nsf::st_polygon(polygon_list) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n```\n\n\n:::\n\n```{.r .cell-code}\n## POLYGON with a hole\npolygon_border = base::rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))\npolygon_hole = base::rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))\npolygon_with_hole_list = base::list(polygon_border, polygon_hole)\nsf::st_polygon(polygon_with_hole_list) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\n```\n\n\n:::\n\n```{.r .cell-code}\n## MULTILINESTRING\nmultilinestring_list = base::list(base::rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            base::rbind(c(1, 2), c(2, 4)))\nsf::st_multilinestring(multilinestring_list) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\n```\n\n\n:::\n\n```{.r .cell-code}\n## MULTIPOLYGON\nmultipolygon_list = base::list(base::list(base::rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),\n                         base::list(base::rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))\nsf::st_multipolygon(multipolygon_list) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\n```\n\n\n:::\n\n```{.r .cell-code}\n## GEOMETRYCOLLECTION\ngeometrycollection_list = base::list(sf::st_multipoint(multipoint_matrix),\n                              sf::st_linestring(linestring_matrix))\nsf::st_geometrycollection(geometrycollection_list) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> GEOMETRYCOLLECTION (MULTIPOINT ((5 2), (1 3), (3 4), (3 2)), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nI have `base::` not prefixed to `c()`.\n:::\n::::::\n:::::::::::::::\n::::::::::::::::\n::::::::::::::::::::\n\n### Simple feature columns (sfc) {#sec-02-sf-sfc}\n\nOne <a class='glossary' title='Simple Feature Geometry (SFG) is a fundamental concept in the sf package for R, used for representing the geometry of a single spatial feature. SFG objects can represent various types of geometries, such as points, lines, and polygons. These geometries are encoded using well-known binary (WKB) or well-known text (WKT) formats, which are human-readable representations of the geometries. SFG objects are implemented as native R data structures, such as vectors, matrices, or lists of matrices, depending on the geometry type. They consist of three classes corresponding to the dimensions, geometry type, and the SFG class itself. Additionally, SFG objects possess coordinates, which can be represented as a vector or a matrix.'>sfg</a> object contains only a single simple feature\ngeometry. A simple feature geometry column (<a class='glossary' title='A Simple Feature Collection or Simple Feature Columns (SFC) is a fundamental data structure in the sf package for R, used for handling spatial data. It is a list-column that contains simple feature geometries, typically of the same type, but it can also contain a mix of different types. Each element in the list represents a single geometry, such as a point, line, or polygon. A simple feature geometry list-column is a list of class c(“sfc_”, “sfc”) which most often contains objects of identical type; in case of a mix of types or an empty set,  is set to the superclass GEOMETRY.'>sfc</a>) is a\nlist of sfg objects, which is additionally able to contain information\nabout the <a class='glossary' title='A Coordinate Reference System (CRS) defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a> in use. For instance, to combine two\nsimple features into one object with two features, we can use the\n`sf::st_sfc()` function. This is important since **sfc represents the\ngeometry column in sf data frames**.\n\n::::::::::::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-02-sfc}\n: Simple feature columns (sfc)\n:::\n:::::\n\n::::::::::::::::::::: my-code-collection-container\n:::::::::::::::::::: panel-tabset\n###### sfc POINT\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sfc-point}\n: Geometry set of two POINTS features\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoint1 = sf::st_point(c(5, 2))\npoint2 = sf::st_point(c(1, 3))\npoints_sfc = sf::st_sfc(point1, point2)\npoints_sfc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Geometry set for 2 features \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3\n#> CRS:           NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT (5 2)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT (1 3)\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nBesides returning the dimensions of the bounding box it also returns the\n<a class='glossary' title='A Coordinate Reference System (CRS) defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a>. In this case it is `NA` (not available)\n:::\n::::::\n\n###### sfc POLYGON\n\n::::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-sfc-polygon}\n: Geometry set of two POLYGON features and showing the resulting sfc\ntypes\n:::\n::::\n\n:::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\npolygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\npolygon1 = sf::st_polygon(polygon_list1)\npolygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))\npolygon2 = sf::st_polygon(polygon_list2)\n( polygon_sfc = sf::st_sfc(polygon1, polygon2) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Geometry set for 2 features \n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 0 ymin: 1 xmax: 4 ymax: 5\n#> CRS:           NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POLYGON ((0 2, 1 2, 1 3, 0 3, 0 2))\n```\n\n\n:::\n\n```{.r .cell-code}\n( geom_type <- sf::st_geometry_type(polygon_sfc) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] POLYGON POLYGON\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::class(polygon_sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sfc_POLYGON\" \"sfc\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::class(geom_type)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::levels(geom_type)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] \"GEOMETRY\"           \"POINT\"              \"LINESTRING\"        \n#>  [4] \"POLYGON\"            \"MULTIPOINT\"         \"MULTILINESTRING\"   \n#>  [7] \"MULTIPOLYGON\"       \"GEOMETRYCOLLECTION\" \"CIRCULARSTRING\"    \n#> [10] \"COMPOUNDCURVE\"      \"CURVEPOLYGON\"       \"MULTICURVE\"        \n#> [13] \"MULTISURFACE\"       \"CURVE\"              \"SURFACE\"           \n#> [16] \"POLYHEDRALSURFACE\"  \"TIN\"                \"TRIANGLE\"\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nIn most cases, an sfc object contains objects of the same geometry type.\nTherefore, when we convert sfg objects of type polygon into a simple\nfeature geometry column, we would also end up with an sfc object of type\npolygon, which can be verified with `sf::st_geometry_type()`.\n\n(You will get a similar result binding several MULTILINESTRINGs\ntogether, or another type of geometry. I will skip this code chunk.)\n\nAdditionally I was here interested to get all 18 levels of the geometry\ntype of \"polygon_sfc\" with `base::levels()`. I knew already of the first\neight but the rest are new to me. Detailed information about all types\ncan be found in the {**sf**} vignette [1. Simple Features of\nR](https://r-spatial.github.io/sf/articles/sf1.html) under the section\n[Simple feature geometry\ntypes](https://r-spatial.github.io/sf/articles/sf1.html#simple-feature-geometry-types).\n\n::: {#nte-02-difference-gemoetry-geometrycollection .callout-note}\n###### What is the difference between GEOMETRY and GEOMETRYCOLLECTION?\n\n-   GEOMETRY is used to describe a **list of geometries** of varying\n    types or an empty set.\n-   GEOMETRYCOLLECTION is used to describe a **single geometry** that\n    can contain multiple types of geometries.\n:::\n\n(Here I have abstained from prefixing `base::` to `c()`, `list()` and\n`rbind()`)\n::::\n:::::::\n\n###### sfc GEOMETRY\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sfc-geometry}\n: Geometry set of two different geometry features and showing the\nresulting sfc types\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoint_polygon_sfc = sf::st_sfc(point1, polygon1) \nsf::st_geometry_type(point_polygon_sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] POINT   POLYGON\n#> 18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(point_polygon_sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sfc_GEOMETRY\" \"sfc\"\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nIt is also possible to create an sfc object from sfg objects with\ndifferent geometry types. It results in the superclass GEOMETRY.\n:::\n::::::\n\n###### Set CRS\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-set-crs}\n: Check and set Coordinate Reference System (CRS)\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check the CRS\nsf::st_crs(points_sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Coordinate Reference System: NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# Set the CRS with an identifier referring to an 'EPSG' CRS code:\npoints_sfc_wgs = sf::st_sfc(point1, point2, crs = \"EPSG:4326\")\n\n# print CRS\nsf::st_crs(points_sfc_wgs) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Coordinate Reference System:\n#>   User input: EPSG:4326 \n#>   wkt:\n#> GEOGCRS[\"WGS 84\",\n#>     ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n#>         MEMBER[\"World Geodetic System 1984 (Transit)\"],\n#>         MEMBER[\"World Geodetic System 1984 (G730)\"],\n#>         MEMBER[\"World Geodetic System 1984 (G873)\"],\n#>         MEMBER[\"World Geodetic System 1984 (G1150)\"],\n#>         MEMBER[\"World Geodetic System 1984 (G1674)\"],\n#>         MEMBER[\"World Geodetic System 1984 (G1762)\"],\n#>         MEMBER[\"World Geodetic System 1984 (G2139)\"],\n#>         ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n#>             LENGTHUNIT[\"metre\",1]],\n#>         ENSEMBLEACCURACY[2.0]],\n#>     PRIMEM[\"Greenwich\",0,\n#>         ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     CS[ellipsoidal,2],\n#>         AXIS[\"geodetic latitude (Lat)\",north,\n#>             ORDER[1],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         AXIS[\"geodetic longitude (Lon)\",east,\n#>             ORDER[2],\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>     USAGE[\n#>         SCOPE[\"Horizontal component of 3D system.\"],\n#>         AREA[\"World.\"],\n#>         BBOX[-90,-180,90,180]],\n#>     ID[\"EPSG\",4326]]\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nAll geometries in sfc objects must have the same <a class='glossary' title='A Coordinate Reference System (CRS) defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a>. A\nCRS can be specified with the crs argument of `sf::st_sfc()` (or\n`sf::st_sf()`), which takes a CRS identifier provided as a text string,\nsuch as `crs = \"EPSG:4326\"` (see @XXXSection7-2 for other CRS\nrepresentations and details on what this means).\n:::\n::::::\n::::::::::::::::::::\n:::::::::::::::::::::\n:::::::::::::::::::::::::\n\n### The sfheaders package\n\n{**sfheaders**} is an R package that speeds-up the construction,\nconversion and manipulation of `sf` objects [@sfheaders]). It focuses on\nbuilding `sf` objects from vectors, matrices and data frames, rapidly,\nand without depending on the {**sf**} library; and exposing its\nunderlying C++ code through header files (hence the name, sfheaders).\n(See the package profile at @sec-96-sfheaders.)\n\nThis approach enables others to extend it using compiled and\nfast-running code. Every core {**sfheaders**} function has a\ncorresponding C++ implementation, as described in the [Cpp\nvignette](https://dcooley.github.io/sfheaders/articles/Cpp.html). For\nmost people, the R functions will be more than sufficient to benefit\nfrom the computational speed of the package. {**sfheaders**} was\ndeveloped separately from {**sf**}, but aims to be fully compatible,\ncreating valid `sf` objects of the type described in preceding sections.\n\nThe simplest use case for sfheaders is demonstrated in the code chunks\nbelow with examples of building `sfg`, `sfc`, and `sf` objects showing:\n\n-   A vector converted to sfg_POINT\n-   A matrix converted to sfg_LINESTRING\n-   A data frame converted to sfg_POLYGON\n\n:::::::::::::::::::::::::::: my-code-collection\n::::: my-code-collection-header\n::: my-code-collection-icon\n:::\n\n::: {#exm-ID}\n: Title for code collection\n:::\n:::::\n\n:::::::::::::::::::::::: my-code-collection-container\n::::::::::::::::::::::: panel-tabset\n###### Vector\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sfheaders-vector}\n: Creating the simplest possible sfg object\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv = base::c(1, 1)\nv_sfg_sfh = sfheaders::sfg_point(obj = v)\nv_sfg_sfh # printing without sf loaded\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT (1 1)\n```\n\n\n:::\n\n```{.r .cell-code}\n#>      [,1] [,2]\n#> [1,]    1    1\n#> attr(,\"class\")\n#> [1] \"XY\"    \"POINT\" \"sfg\" \n\n\n# printing with sf loading\nv_sfg_sf = sf::st_point(v)\nbase::print(v_sfg_sf) == print(v_sfg_sfh)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT (1 1)\n#> POINT (1 1)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n\nThis creates the simplest possible sfg object, a single coordinate pair,\nassigned to a vector named v:\n\nInstead to get as result the underlying structure from the first part of\nthe code (it should result in the four lines of the out-commented code)\nI got just `POINT (1 1)`. I do not know why this is the case. The\nversion 0.4.4 from 2024-01-18 I have used here newer than the version in\nthe book. Perhaps that the reason that the results are now identical\nbetween loading {**sf**} and not loading it?\n\nWhen printing with {sf} loaded, my result is identical with the output\nin the book.\n:::\n::::::\n\n###### Matrix and data.frame\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sfheaders-matrix-df}\n: Creating `sfg` objects from matrices and data frames with\n{**sfheaders**}\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# matrices\nm = base::matrix(1:8, ncol = 2)\nsfheaders::sfg_linestring(obj = m)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> LINESTRING (1 5, 2 6, 3 7, 4 8)\n```\n\n\n:::\n\n```{.r .cell-code}\n# data frames\ndf = base::data.frame(x = 1:4, y = 4:1)\nsfheaders::sfg_polygon(obj = df)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POLYGON ((1 4, 2 3, 3 2, 4 1, 1 4))\n```\n\n\n:::\n:::\n\n\n\n------------------------------------------------------------------------\n:::\n::::::\n\n###### sfc\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sfheaders-sfc}\n: Creating simple feature columns (`sfc`) with {**sfheaders**}\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsfheaders::sfc_point(obj = v)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Geometry set for 1 feature \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 1 xmax: 1 ymax: 1\n#> CRS:           NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT (1 1)\n```\n\n\n:::\n\n```{.r .cell-code}\nsfheaders::sfc_linestring(obj = m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Geometry set for 1 feature \n#> Geometry type: LINESTRING\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 5 xmax: 4 ymax: 8\n#> CRS:           NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> LINESTRING (1 5, 2 6, 3 7, 4 8)\n```\n\n\n:::\n\n```{.r .cell-code}\nsfheaders::sfc_polygon(obj = df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Geometry set for 1 feature \n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 4\n#> CRS:           NA\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POLYGON ((1 4, 2 3, 3 2, 4 1, 1 4))\n```\n\n\n:::\n:::\n\n\n:::\n::::::\n\n###### sf\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sfheaders-sf}\n: Creating sf objects with {**sfheaders**}\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsfheaders::sf_point(obj = v)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Simple feature collection with 1 feature and 0 fields\n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 1 xmax: 1 ymax: 1\n#> CRS:           NA\n#>      geometry\n#> 1 POINT (1 1)\n```\n\n\n:::\n\n```{.r .cell-code}\nsfheaders::sf_linestring(obj = m)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Simple feature collection with 1 feature and 1 field\n#> Geometry type: LINESTRING\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 5 xmax: 4 ymax: 8\n#> CRS:           NA\n#>   id                       geometry\n#> 1  1 LINESTRING (1 5, 2 6, 3 7, ...\n```\n\n\n:::\n\n```{.r .cell-code}\nsfheaders::sf_polygon(obj = df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Simple feature collection with 1 feature and 1 field\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 1 ymin: 1 xmax: 4 ymax: 4\n#> CRS:           NA\n#>   id                       geometry\n#> 1  1 POLYGON ((1 4, 2 3, 3 2, 4 ...\n```\n\n\n:::\n:::\n\n\n:::\n::::::\n\n###### CRS\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-sfheaders-crs}\n: Setting the CRS for calculations or geometric operations using\n{**sf**} functions\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_sf = sfheaders::sf_polygon(obj = df)\nsf::st_crs(df_sf) = \"EPSG:4326\"\n```\n:::\n\n\n\nIn all of the previous examples of this code collection, the CRS was not\ndefined. If you plan on doing any calculations or geometric operations\nusing sf functions, we encourage you to set the CRS (see @XXXChapter7\nfor details):\n:::\n::::::\n:::::::::::::::::::::::\n::::::::::::::::::::::::\n::::::::::::::::::::::::::::\n\n{**sfheaders**} is also good at ‘deconstructing’ and ‘reconstructing’\n`sf` objects, meaning converting geometry columns into data frames that\ncontain data on the coordinates of each vertex and geometry feature (and\nmulti-feature) ids. It is fast and reliable at ‘casting’ geometry\ncolumns to different types, a topic covered in @XXXChapter5. Benchmarks,\nin the [package’s\ndocumentation](https://dcooley.github.io/sfheaders/articles/examples.html#performance)\nshow it is much faster than the {**sf**} package for such operations.\n\n:::::: my-remark\n:::: my-remark-header\n::: {#rem-02-sfheaders}\n: {**sfheaders**} at the moment for me not relevant\n:::\n::::\n\n::: my-remark-container\nI understand that the biggest advantage of {**sfheaders**} is speed in\nthe calculation. At the moment I agree with the following observation:\n\n> For most people, the R functions \\[of the {**sf**} package\\] will be\n> more than sufficient to benefit from the computational speed of the\n> package.\n\nAdditionally I am still lacking experience with {**sf**} and therefore\ndon't want to learn similar packages at the same time.\n:::\n::::::\n\n### Spherical geometry operations with S2 {#sec-02-s2}\n\nSince {**sf**} version 1.0.0, R supports spherical geometry operations\n‘out of the box’ (and by default), thanks to its interface to Google’s\nS2 spherical geometry engine via the {**s2**} interface package (s2\npackage profile: @sec-96-s2).\n\nS2 is perhaps best known as an example of a Discrete Global Grid System\n(<a class='glossary' title='A Discrete Global Grid System (DGGS) is a method of dividing the Earth’s surface into a mosaic of cells, each with a unique identifier. This system simplifies spatial calculations and allows for hierarchical organization, where each cell can contain smaller cells, creating a grid with progressively finer resolution.'>DGGS</a>). Another example is the [H3](https://h3geo.org/)\nglobal hexagonal hierarchical spatial index, supported by the R packages\n{h3r}, {h3jsr}, and {h3lib}. The differences is a complex theme I don't\nwant to tackle yet with my insufficient geocomputing knowledge.\n\nAlthough potentially useful for describing locations anywhere on Earth\nusing character strings, the main benefit of {**sf**}’s interface to\n{**S2**} is its provision of drop-in functions for calculations such as\ndistance, buffer, and area calculations, as described in [vignette\n7](https://r-spatial.github.io/sf/articles/sf7.html) of {**sf**}’s\ndocumentation.\n\n{**sf**} can run in two modes with respect to {**S2**}: on and off. By\ndefault the {**S2**} geometry engine is turned on, as can be verified\nwith the following command: `sf::sf_use_s2()` results in\nTRUE.\n\nAn example of the consequences of turning the geometry engine off can be\nshown, by creating buffers around the india object created earlier in\nthe chapter (note the warnings emitted when S2 is turned off):\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-diff-s2-on-off}\n: Example of the consequences of turning the geometry engine off\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindia_buffer_with_s2 = sf::st_buffer(india, 1) # 1 meter\nsf::sf_use_s2(FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Spherical geometry (s2) switched off\n```\n\n\n:::\n\n```{.r .cell-code}\nindia_buffer_without_s2 = sf::st_buffer(india, 1) # 1 degree\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle =\n#> endCapStyle, : st_buffer does not correctly buffer longitude/latitude data\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> dist is assumed to be in decimal degrees (arc_degrees).\n```\n\n\n:::\n:::\n\n\n:::\n::::::\n\n![Example of the consequences of turning off the S2 geometry\nengine.](img/02-s2example-2-border-min.png){#fig-02-s2-example\nfig-alt=\"alt-text\" fig-align=\"center\" width=\"100%\"}\n\nBoth representations of a buffer around India were created with the same\ncommand `sf::st_buffer(india, 1)` but the purple polygon object was\ncreated with S2 switched on, resulting in a buffer of 1 m. The larger\nlight green polygon was created with S2 switched off, resulting in a\nbuffer of 1 degree, which is not accurate.\n\nThe right panel of Figure 2.12 is incorrect, as the buffer of 1 degree\ndoes not return the equal distance around the india polygon. (The\nexplanation why this is the case comes in @XXXSection7-4).\n\nThroughout this book, we will assume that S2 is turned on, unless\nexplicitly stated. There some edge cases include operations on polygons\nthat are not valid according to S2’s stricter definition. If you see\nerror messages such as `#> Error in s2_geography_from_wkb ...` it may be\nworth trying the command that generated the error message again, after\nturning off S2.\n\n:::::: my-r-code\n:::: my-r-code-header\n::: {#cnj-02-turn-on-s2}\n: Turn S2 on again\n:::\n::::\n\n::: my-r-code-container\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf::sf_use_s2(TRUE)\nsf::sf_use_s2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n::::::\n\n## Raster data\n\nThe spatial raster data model represents the world with the continuous\ngrid of cells (often also called pixels). It usually consists of a\nraster header and a matrix (with rows and columns) representing equally\nspaced cells. The raster header defines the CRS, the extent and the\norigin. The origin (or starting point) is frequently the coordinate of\nthe lower left corner of the matrix (the {**terra**} package, however,\nuses the upper left corner, by default. The header defines the extent\nvia the number of columns, the number of rows and the cell size\nresolution.\n\nStarting from the origin, we can easily access and modify each single\ncell by either using the ID of a cell or by explicitly specifying the\nrows and columns. This and map algebra (@XXXSection4-3-2) make raster\nprocessing much more efficient and faster than vector data processing.\nIn contrast to vector data, the cell of one raster layer can only hold a\nsingle value[^02-geographic-data-1]. The value might be continuous or\ncategorical.\n\n[^02-geographic-data-1]: Thus to store many values for a single location\n    we need to have many raster layers.\n\nRaster maps usually represent continuous phenomena such as elevation, temperature, population density or spectral data. Discrete features such as soil or land-cover classes can also be represented in the raster data model. Depending on the nature of the application, vector representations of discrete features may be more suitable.\n\n### R packages for working with raster data\n\nMost important nowadays is {**terra**}, which replaces the older {**raster**} and {**stars**}. This book focuses on {**terra**} but it is important to know the differences to {**stars**}:\n\n- {**terra**} focuses on the most common raster data model (regular grids), while stars also allows storing less popular models (including regular, rotated, sheared, rectilinear, and curvilinear grids). \n- {**terra**} usually handles one or multi-layered rasters, whereas {**stars**} provides ways to store raster data cubes – a raster object with many layers (e.g., bands), for many moments in time (e.g., months), and many attributes (e.g., sensor type A and sensor type B). \n\n- In both packages all layers or elements of a data cube must have the same spatial dimensions and extent. Both packages allow to either read all of the raster data into memory or just to read its metadata – this is usually done automatically based on the input file size. However, they store raster values very differently. \n\n- {**terra**} is based on C++ code and mostly uses C++ pointers whereas {**stars**} stores values as lists of arrays for smaller rasters or just a file path for larger ones. \n- {**terra**} uses its own class of objects for vector data, namely `SpatVector`, but also accepts {**sf**} classes, whereas {**stars**} functions are closely related to the vector objects and functions in {**sf**}.  \n\nBut it also possible to convert between these classes: `terra::vect()` from `sf` to `SpatVector` and `sf::st_as_sf()` from `SpatVector` to `sf`.\n\nFourth, both packages have a different approach for how various functions work on their objects. \n\n- {**terra**} mostly relies on a large number of built-in functions, where each function has a specific purpose (e.g., resampling or cropping). On the other hand, {**stars**} uses some built-in functions (usually with names starting with `st_`), some existing {**dplyr**} functions (e.g., `dplyr::filter()` or `dplyr::slice()`), and also has its own methods for existing R functions (e.g., `base::split()` or or `stats::aggregate()`).\n\nImportantly, it is straightforward to convert objects from {**terra**} to {**stars**} (using `sf::st_as_stars()`) and the other way round (using `terra::rast()`). We also encourage you to read [@pebesma-2023] for the most comprehensive introduction to the {**stars**} package.\n\n### Introduction to {**terra**}\n\n- The {**terra**} package supports raster objects in R. It provides an extensive set of functions to create, read, export, manipulate and process raster datasets. \n- In addition to functions for raster data manipulation, {**terra**} provides many low-level functions that can form a foundation for developing new tools for working with raster datasets. \n- {**terra**} also lets you work on large raster datasets that are too large to fit into the main memory. In this case, terra provides the possibility to divide the raster into smaller chunks, and processes these iteratively instead of loading the whole raster file into RAM.\n\nFor the illustration of terra concepts, we will use datasets from the {**spDataLarge**} (Nowosad and Lovelace 2023). It consists of a few raster objects and one vector object covering an area of Zion National Park (Utah, USA). For example, srtm.tif is a digital elevation model of this area (SRMT stands for [Shuttle Radar Topography Mission](https://www.earthdata.nasa.gov/data/instruments/srtm)). Let’s create a `SpatRaster` object and get information about its class and content.\n\n\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-terra-functions}\n: Introduction to {**terra**} functions\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### SpatRaster object\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-create-spatraster-object}\n: Create a SpatRaster object from \"srtm.tif\"\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraster_filepath = base::system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nmy_rast = terra::rast(raster_filepath)\nbase::class(my_rast)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"SpatRaster\"\n#> attr(,\"package\")\n#> [1] \"terra\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_rast\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> class       : SpatRaster \n#> dimensions  : 457, 465, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.0008333333, 0.0008333333  (x, y)\n#> extent      : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 (EPSG:4326) \n#> source      : srtm.tif \n#> name        : srtm \n#> min value   : 1024 \n#> max value   : 2892\n```\n\n\n:::\n\n```{.r .cell-code}\nmy_rast2 <- terra::wrap(my_rast)\nmy_rast2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"This is a PackedSpatRaster object. Use 'terra::unwrap()' to unpack it\"\n```\n\n\n:::\n:::\n\n\n\n***\n\nThe name of the raster will print out the raster header (dimensions, resolution, extent, CRS) and some additional information (class, data source, and a summary of the raster values).\n\n::: {.callout-warning #wrn-02-no-raster-values-but-pointer}\n\n###### `SpatRaster` objects do not store raster values\n\nMost `SpatRaster` objects do not store raster values, but rather a pointer to the file itself. This has a significant side-effect – they cannot be directly saved to `.rds` or `.rd`a files or used in a different R session. Therefore I got \n\n> Error in `.External()`: ! NULL value passed as symbol address. \n\nWhen I ran the code chunk in @cnj-02-basic-maps as `terra::plot(my_rast)` it worked, but I got the error whenever I rendered the whole document.\n\nIn these cases, there are two main possible solutions: \n\n1. use of the `terra::wrap()` function that creates a special kind of temporary object that can be saved as an R object or used in cluster computing, or \n2. save the object as a regular raster with `terra::writeRaster()` as I have done i @cnj-02-create-multi-raster.\n\nUsing the values of `SpatRaster` in another session one needs to `terra::unwrap()` the object as I have done in @cnj-02-basic-maps.\n:::\n\n::::\n:::::\n\n\n###### Raster header\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-raster-header}\n: Reporting each component of the raster header with dedicated functions\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::dim(my_rast)          # returns the number of rows, columns and layers; \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 457 465   1\n```\n\n\n:::\n\n```{.r .cell-code}\nterra::ncell(my_rast)       # returns the number of cells (pixels); \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 212505\n```\n\n\n:::\n\n```{.r .cell-code}\nterra::res(my_rast)         # returns the spatial resolution; \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.0008333333 0.0008333333\n```\n\n\n:::\n\n```{.r .cell-code}\nterra::ext(my_rast)         # return the spatial extent; and \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> SpatExtent : -113.239583212784, -112.85208321281, 37.1320834298579, 37.5129167631658 (xmin, xmax, ymin, ymax)\n```\n\n\n:::\n\n```{.r .cell-code}\nterra::crs(my_rast)         # return the CRS  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"GEOGCRS[\\\"WGS 84\\\",\\n    ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n        MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n        MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n        ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        ENSEMBLEACCURACY[2.0]],\\n    PRIMEM[\\\"Greenwich\\\",0,\\n        ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    CS[ellipsoidal,2],\\n        AXIS[\\\"geodetic latitude (Lat)\\\",north,\\n            ORDER[1],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        AXIS[\\\"geodetic longitude (Lon)\\\",east,\\n            ORDER[2],\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n    USAGE[\\n        SCOPE[\\\"Horizontal component of 3D system.\\\"],\\n        AREA[\\\"World.\\\"],\\n        BBOX[-90,-180,90,180]],\\n    ID[\\\"EPSG\\\",4326]]\"\n```\n\n\n:::\n\n```{.r .cell-code}\nterra::inMemory(my_rast)    # reports whether the raster data is stored in memory or on disk, and \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nterra::sources(my_rast)     # specifies the file location\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"/Library/Frameworks/R.framework/Versions/4.4-x86_64/library/spDataLarge/raster/srtm.tif\"\n```\n\n\n:::\n:::\n\n\n\n***\n\nDedicated functions report each component of the raster header (dimensions, resolution, extent, CRS) and some additional information (class, data source, summary of the raster values): \n\n- `base::dim()` returns the number of rows, columns and layers; \n- `terra::ncell()` returns the number of cells (pixels); \n- `terra::res()` returns the spatial resolution; \n- `terra::ext()` return the spatial extent; and \n- `terra::crs()` return the <a class='glossary' title='A Coordinate Reference System (CRS) defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a> (raster reprojection is covered in @XXXSection7-8). \n- `terra::inMemory()` reports whether the raster data is stored in memory or on disk, and \n- `terra::sources()` specifies the file location.\n\nThe function `terra::dim()` didn't work for me but it should be on of the \"dedicated functions\" of {**terra**}. I had to replace it with `base::dim()`.\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n:::::{.my-remark}\n:::{.my-remark-header}\n:::::: {#rem-02-terra-use-cases}\n: {**terra**} package not essential for my use cases\n::::::\n:::\n::::{.my-remark-container}\nAs I am mostly interested to compare parameters for different countries it seems to me that vector data are the data type I have to go with.\n::::\n:::::\n\n\n::: {.callout-note #nte-02-terra-overview}\n###### Overview of all {**terra**} functions\n\nTyping `help(\"terra-package\")` into the console you will get a list of all available {**terra**} function in the package help file. The same information you will get as an [article in the package description on the web](https://rspatial.github.io/terra/reference/terra-package.html).\n:::\n\n### Basic map-making\n\nSimilar to the {**sf**} package, {**terra**} also provides `plot()` methods for its own classes.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-basic-maps}\n: Basic map-making\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nterra::plot(terra::unwrap(my_rast2))\n```\n\n::: {.cell-output-display}\n![](02-geographic-data_files/figure-html/basic-maps-1.png){width=672}\n:::\n:::\n\n\n***\n\nI have used here `terra::unwrap(my_rast2)` to prevent an error described in @wrn-02-no-raster-values-but-pointer.\n\n::::\n:::::\n\nThere are several other approaches for plotting raster data in R that are outside the scope of this section, including:\n\n- `terra::plotRGB()` function from the terra package to create a plot based on three layers in a SpatRaster object\n- Packages such as {**tmap**} to create static and interactive maps of raster and vector objects (see @XXXChapter9)\n- Functions, for example `rasterVis::levelplot()` from the {**rasterVis**} package, to create facets, a common technique for visualizing change over time\n\n### Raster classes\n\nThe `SpatRaster` class represents rasters object of {**terra**}. The easiest way to create a raster object in R is to read-in a raster file from disk or from a server (@XXXSection8-3-2).\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-create-raster-object}\n: Create a raster object\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Reading file\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-create-from-reading-file}\n: Create a raster object by reading a file from disk or server\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraster_filepath = base::system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nsingle_rast = terra::rast(raster_filepath)\n```\n:::\n\n\n\n***\n\nI had to change \"single_raster_file\" in the first line to `raster_filepath`. Should I create a pull request (PR) to patch this mistake?\n\nThe {**terra**} package supports numerous drivers with the help of the <a class='glossary' title='The Geospatial Data Abstraction Library (GDAL) is a computer software library for reading and writing raster and vector geospatial data formats (e.g. shapefile), and is released under the permissive X/MIT style free software license by the Open Source Geospatial Foundation. As a library, it presents a single abstract data model to the calling application for all supported formats. (Wikipedia)'>GDAL</a> library. With `terra::gdal(drivers = TRUE)` you will get all the 200 different drivers that are available to date (2025-02-02) or (even better) use the up-to-date [GDAL web documented list of drivers](https://gdal.org/en/latest/drivers/raster/index.html).  GDAL is the software library that {**terra**} builds on to read and write spatial data and for some raster data processing.\n\nThese classes hold a C++ pointer to the data \"reference class\" and that creates some limitations. They cannot be recovered from a saved R session either or directly passed to nodes on a computer cluster. Generally, you should use `terra::writeRaster()` to save `SpatRaster` objects to disk (and pass a filename or cell values of cluster nodes). See for example @cnj-02-create-multi-raster.  Or use `terra::wrap()` as I have done in @cnj-02-create-spatraster-object.\n::::\n:::::\n\n\n###### From scratch\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-create-from-scratch}\n: Create raster object from scratch\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_raster = terra::rast(nrows = 6, ncols = 6, \n                  xmin = -1.5, xmax = 1.5, ymin = -1.5, ymax = 1.5,\n                  vals = 1:36)\nnew_raster\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> class       : SpatRaster \n#> dimensions  : 6, 6, 1  (nrow, ncol, nlyr)\n#> resolution  : 0.5, 0.5  (x, y)\n#> extent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)\n#> coord. ref. : lon/lat WGS 84 \n#> source(s)   : memory\n#> name        : lyr.1 \n#> min value   :     1 \n#> max value   :    36\n```\n\n\n:::\n:::\n\n\n\n***\n\nRasters can also be created from scratch, illustrated in the above code chunk. The resulting raster consists of 36 cells (6 columns and 6 rows specified by nrows and ncols) centered around the Prime Meridian and the Equator (see xmin, xmax, ymin and ymax parameters). Values (vals) are assigned to each cell: 1 to cell 1, 2 to cell 2, and so on. Remember: `terra::rast()` fills cells row-wise (unlike `base::matrix()`) starting at the upper left corner, meaning the top row contains the values 1 to 6, the second 7 to 12, etc. Raster objects can also created from another object (see: [Create a SpatRaster](https://rspatial.github.io/terra/reference/rast.html)).\n\nGiven the number of rows and columns as well as the extent (xmin, xmax, ymin, ymax), the resolution has to be 0.5. The unit of the resolution is that of the underlying <a class='glossary' title='A Coordinate Reference System (CRS) defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a>. Here, it is degrees, because the default CRS of raster objects is <a class='glossary' title='WGS84, or the World Geodetic System 1984, is a global reference system used for geospatial information, providing a standard coordinate frame for the Earth. It is widely used for navigation, positioning, and targeting by the Department of Defense, NATO, and other international organizations. WGS84 defines a datum and reference ellipsoid, which is crucial for determining positions on the Earth’s surface with high accuracy. This system allows for the consistent representation of geographic locations using latitude, longitude, and ellipsoidal height.'>WGS84</a>. However, one can specify any other CRS with the `crs` argument.\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\nThe `SpatRaster` class also handles multiple layers, which typically correspond to a single multi-spectral satellite file or a time-series of rasters.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-raster-multiple-layers}\n: Handling multiple raster layers\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Create multi raster\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-create-multi-raster}\n: Creating raster with multiple layers\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_raster_file = base::system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_rast = terra::rast(multi_raster_file)\nmulti_rast\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> class       : SpatRaster \n#> dimensions  : 1428, 1128, 4  (nrow, ncol, nlyr)\n#> resolution  : 30, 30  (x, y)\n#> extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\n#> coord. ref. : WGS 84 / UTM zone 12N (EPSG:32612) \n#> source      : landsat.tif \n#> names       : landsat_1, landsat_2, landsat_3, landsat_4 \n#> min values  :      7550,      6404,      5678,      5252 \n#> max values  :     19071,     22051,     25780,     31961\n```\n\n\n:::\n\n```{.r .cell-code}\npb_create_folder(\"data\")\npb_create_folder(\"data/Chapter2\")\n\nterra::writeRaster(\n  multi_rast,\n  \"data/Chapter2/landsat.tif\",\n  overwrite = TRUE,\n  datatype = \"FLT4S\"\n  ) \n```\n:::\n\n\n\n\n\n::::\n:::::\n\n\n###### Raster layers\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-get-number-of-raster-layers}\n: Get number of raster layers\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_rast <- terra::rast(\"data/Chapter2/landsat.tif\")\n\n\nterra::nlyr(multi_rast)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n:::\n\n\n\n::::\n:::::\n\n###### Select & combine layers\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-subset-raster-layers}\n: Select (subset) raster layers\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_rast <- terra::rast(\"data/Chapter2/landsat.tif\")\n\nmulti_rast3 = terra::subset(multi_rast, 3)\nmulti_rast4 = terra::subset(multi_rast, \"landsat_4\")\n\nmulti_rast34 = base::c(multi_rast3, multi_rast4)\n```\n:::\n\n\n\n::::\n:::::\n\n\n\n\n\n:::\n\nAs `SpatRaster` objects do not save the data but only a pointer I had to look ahead to @XXXSection8-4-2. and save the `SpatRaster` object with `terra::writeRaster()` to the disk. Then I had always to load the saved `.tif` object and restore is as `SpatRaster` object with `terra::rast()`. I do not know yet if this cumbersome method (always creating ) is correct or if there is a simpler posssibility. (See for instance the [discussion on GitHub](https://github.com/rspatial/terra/issues/549))\n\n::::\n:::::\n\n\n\n## Coordinate Reference Systems\n\nThe coordinate reference systems (CRSs) defines how the spatial elements of the data relate to the surface of the Earth (or other bodies). CRSs are either geographic or projected.\n\n### Geographic coordinate reference systems\n\nGeographic CRSs identify any location on the Earth’s surface using two values — longitude and latitude. Longitude is location in the East-West direction in angular distance from the Prime Meridian plane. Latitude is angular distance North or South of the equatorial plane. Distances in geographic CRSs are therefore not measured in meters. This has important consequences, as demonstrated in @XXXChapter7.\n\nThe surface of the Earth in geographic CRSs is represented by a spherical or ellipsoidal surface. Spherical models assume that the Earth is a perfect sphere of a given radius – they have the advantage of simplicity but, at the same time, they are inaccurate as the Earth is not exactly a sphere. Ellipsoidal models are slightly more accurate, and are defined by two parameters: the equatorial radius and the polar radius. These are suitable because the Earth is compressed: the equatorial radius is around 11.5 km longer than the polar radius [@maling-1992].\n\nThe datum contains information on what ellipsoid to use and the precise relationship between the coordinates and location on the Earth’s surface. There are two types of datum — geocentric (such as <a class='glossary' title='WGS84, or the World Geodetic System 1984, is a global reference system used for geospatial information, providing a standard coordinate frame for the Earth. It is widely used for navigation, positioning, and targeting by the Department of Defense, NATO, and other international organizations. WGS84 defines a datum and reference ellipsoid, which is crucial for determining positions on the Earth’s surface with high accuracy. This system allows for the consistent representation of geographic locations using latitude, longitude, and ellipsoidal height.'>WGS84</a>) and local (such as <a class='glossary' title='NAD83, or the North American Datum of 1983, is a geodetic datum used in North America for mapping and surveying. It is a geocentric datum, meaning it is referenced to the center of the Earth’s mass, and it uses the GRS80 reference ellipsoid. This datum provides more accurate coordinates compared to its predecessor, NAD27, because it incorporates satellite data and a denser set of positions, reducing distortions over distance. NAD83 is the most current datum in North America and is used to ensure consistency in geographic coordinates across the continent.'>NAD83</a>).\n\nYou can see examples of these two types of datums in @fig-02-datum-fig. Black lines represent a geocentric datum, whose center is located in the Earth’s center of gravity and is not optimized for a specific location. In a local datum, shown as a purple dashed line, the ellipsoidal surface is shifted to align with the surface at a particular location. These allow local variations in Earth’s surface, for example due to large mountain ranges, to be accounted for in a local CRS. This can be seen in @fig-02-datum-fig, where the local datum is fitted to the area of Philippines, but is misaligned with most of the rest of the planet’s surface. Both datums in @fig-02-datum-fig are put on top of a geoid — a model of global mean sea level.\n\n![Geocentric and local geodetic datums shown on top of a geoid (in false color and the vertical exaggeration by 10,000 scale factor). Image of the geoid is adapted from the work of Ince et al. [@ince2019; @ICGEM-2025]](img/02-datum-fig-min.png){#fig-02-datum-fig\nfig-alt=\"alt-text\" fig-align=\"center\" \nwidth=\"100%\"}\n\n### Projected coordinate reference systems\n\nAll projected CRSs are based on a geographic CRS, described in the previous section, and rely on map projections to convert the three-dimensional surface of the Earth into Easting and Northing (x and y) values in a projected CRS. Projected CRSs are based on Cartesian coordinates on an implicitly flat surface (Figure 2.17, right panel). They have an origin, x and y axes, and a linear unit of measurement such as meters.\n\nThis transition cannot be done without adding some deformations. Therefore, some properties of the Earth’s surface are distorted in this process, such as area, direction, distance, and shape. A projected coordinate reference system can preserve only one or two of those properties. Projections are often named based on a property they preserve: For instance\n\n- **equal-area** preserves area, \n- **azimuthal** preserve direction, \n- **equidistant** preserve distance, and \n- **conformal** preserve local shape.\n\nThere are three main groups of projection types: conic, cylindrical, and planar (azimuthal). \n\n- In a **conic projection**, the Earth’s surface is projected onto a cone along a single line of tangency or two lines of tangency. Distortions are minimized along the tangency lines and rise with the distance from those lines in this projection. Therefore, it is the **best suited for maps of mid-latitude areas**. \n- A **cylindrical projection** maps the surface onto a cylinder. This projection could also be created by touching the Earth’s surface along a single line of tangency or two lines of tangency. Cylindrical projections are **used most often when mapping the entire world**. \n- A **planar projection** projects data onto a flat surface touching the globe at a point or along a line of tangency. It is **typically used in mapping polar regions**. \n\n\n:::::{.my-resource}\n:::{.my-resource-header}\n:::::: {#lem-02-proj-infos}\n: Projections supported by the PROJ library\n::::::\n:::\n::::{.my-resource-container}\n- `sf::sf_proj_info(type = \"proj\")` gives a list of the current 178 available projections supported by the PROJ library. \n- See also details for each projection type that map the spherical 3D space to a flat 2D space at the [PROJ website](https://proj.org/en/stable/operations/projections/index.html).\n- A quick summary of different projections, their types, properties, and suitability can be explored with the Map Projection Explorer at [www.geo-projections.com](https://www.geo-projections.com/).\n::::\n:::::\n\n***\n\n![Examples of geographic (<a class='glossary' title='WGS84, or the World Geodetic System 1984, is a global reference system used for geospatial information, providing a standard coordinate frame for the Earth. It is widely used for navigation, positioning, and targeting by the Department of Defense, NATO, and other international organizations. WGS84 defines a datum and reference ellipsoid, which is crucial for determining positions on the Earth’s surface with high accuracy. This system allows for the consistent representation of geographic locations using latitude, longitude, and ellipsoidal height.'>WGS84</a>; left) and projected (<a class='glossary' title='NAD83, or the North American Datum of 1983, is a geodetic datum used in North America for mapping and surveying. It is a geocentric datum, meaning it is referenced to the center of the Earth’s mass, and it uses the GRS80 reference ellipsoid. This datum provides more accurate coordinates compared to its predecessor, NAD27, because it incorporates satellite data and a denser set of positions, reducing distortions over distance. NAD83 is the most current datum in North America and is used to ensure consistency in geographic coordinates across the continent.'>NAD83</a> / UTM zone 12N; right) coordinate systems for a vector data type.](img/02-vector-crs-min.png){#fig-02-vector-crs\nfig-alt=\"alt-text\" fig-align=\"center\" \nwidth=\"100%\"}\n\n\n***\n\n\n\n:::::{.my-bullet-list}\n:::{.my-bullet-list-header}\nSummary of CRS section\n:::\n::::{.my-bullet-list-container}\nWe will expand on CRSs and explain how to project from one CRS to another in @XXXChapter7. For now, it is sufficient to know:\n\n- Coordinate systems are a key component of geographic objects\n- Which CRS your data is in, and whether it is in geographic (lon/lat) or projected (typically meters), is important and has consequences for how R handles spatial and geometry operations\n- CRSs of {**sf**} objects can be queried with the function `sf::st_crs()` and CRSs of {**terra**} objects can be queried with the function `terra::crs()`.\n::::\n:::::\n\n## Units\n\nAn important feature of CRSs is that they contain information about spatial units. It is good cartographic practice to add a scale bar or some other distance indicator onto maps to demonstrate the relationship between distances on the page or screen and distances on the ground. Likewise, it is important to formally specify the units in which the geometry data or cells are measured to provide context, and to ensure that subsequent calculations are done in the correct context.\n\n### Units in **sf**\n\nA novel feature of geometry data in `sf` objects is that they have **native support for units**. This means that distance, area and other geometric calculations in {**sf**} return values that come with a units attribute, defined by the units package [@units]. (See Package Profile in @sec-96-units.)\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-units-sf}\n: Calculating an area as a {**sf**} units example \n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Area calculation\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-aera-sf-luxembourg}\n: Calculation the Area of Luxembourg\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"world\", package = \"spData\")\n\n(\n  luxembourg <- world |> \n    dplyr::filter(name_long == \"Luxembourg\") |> \n    sf::st_area() # requires {s2} in recent versions of {sf}\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 2408817306 [m^2]\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::attributes(luxembourg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $units\n#> $numerator\n#> [1] \"m\" \"m\"\n#> \n#> $denominator\n#> character(0)\n#> \n#> attr(,\"class\")\n#> [1] \"symbolic_units\"\n#> \n#> $class\n#> [1] \"units\"\n```\n\n\n:::\n:::\n\n\n\n::::\n:::::\n\n\n###### Unit conversion\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-unit-conversion}\n: Translate m^2 into km^2\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nluxembourg / 1000000 # wrong\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 2408.817 [m^2]\n```\n\n\n:::\n\n```{.r .cell-code}\n(\n  luxembourg_km2 <- units::set_units(luxembourg, km^2) # correct\n) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> 2408.817 [km^2]\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::attributes(luxembourg_km2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> $units\n#> $numerator\n#> [1] \"km\" \"km\"\n#> \n#> $denominator\n#> character(0)\n#> \n#> attr(,\"class\")\n#> [1] \"symbolic_units\"\n#> \n#> $class\n#> [1] \"units\"\n```\n\n\n:::\n:::\n\n\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n### Units in **terra**\n\nUnits are of equal importance in the case of raster data. However, so far {**sf**} is the only spatial package that supports units, meaning that people working on raster data should approach changes in the units of analysis (for example, converting pixel widths from imperial to decimal units) with care. The `my_rast` object in @cnj-02-create-spatraster-object uses a <a class='glossary' title='WGS84, or the World Geodetic System 1984, is a global reference system used for geospatial information, providing a standard coordinate frame for the Earth. It is widely used for navigation, positioning, and targeting by the Department of Defense, NATO, and other international organizations. WGS84 defines a datum and reference ellipsoid, which is crucial for determining positions on the Earth’s surface with high accuracy. This system allows for the consistent representation of geographic locations using latitude, longitude, and ellipsoidal height.'>WGS84</a> projection with decimal degrees as units. Consequently, its resolution is also given in decimal degrees, but you have to know it, since the `terra::res()` function simply returns a numeric vector. And if we used the Universal Transverse Mercator (<a class='glossary' title='The Universal Transverse Mercator (UTM) is a map projection system used to assign coordinates to locations on Earth’s surface. It divides the Earth into 60 zones, each 6 degrees of longitude wide, and projects each zone onto a plane. This system uses a transverse Mercator projection for each zone, with a scale factor of 0.9996 at the central meridian to minimize distortion. The zones are numbered consecutively from 1 to 60, starting at 180 degrees longitude and increasing to the east. Each zone has its own central meridian and is projected independently to ensure accuracy within the zone. The UTM system is particularly useful for precise measurements and navigation within a specific zone, as it minimizes distortion compared to a global latitude/longitude system. The UTM system is widely used by the military, NATO, and rescue services for reporting positions, and it is also commonly found on detailed topographic maps.'>UTM</a>) projection, the units would change and we would have to know that the units are now in meter.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-terra-units}\n: Units in {**terra**}\n::::::\n:::\n::::{.my-r-code-container}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nterra::res(terra::unwrap(my_rast2)) # units in decimal degress\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.0008333333 0.0008333333\n```\n\n\n:::\n\n```{.r .cell-code}\nrepr = terra::project(terra::unwrap(my_rast2), \"EPSG:26912\") # UTM projection\nterra::res(repr) # units in meter\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 83.53328 83.53328\n```\n\n\n:::\n:::\n\n\n\n::::\n:::::\n\n## Exercises\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}