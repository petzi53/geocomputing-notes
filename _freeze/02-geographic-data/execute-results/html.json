{
  "hash": "12b492c0c2aeb3ff1f4eacd1cb30553e",
  "result": {
    "engine": "knitr",
    "markdown": "# Geographic Data in R {#sec-chap02}\n\n\n\n\n\n\n\n\n\n\n\n## Introduction\n\nThis chapter will provide explanations of the fundamental geographic\ndata models: vector and raster.\n\n-   **Vector**: The vector data model represents the world using points,\n    lines and polygons. These have discrete, well-defined borders.\n    Vector data tends to dominate the social sciences because human\n    settlements tend to have discrete borders.\n-   **Raster**: The raster data model divides the surface up into cells\n    of constant size. Raster datasets are the basis of background images\n    used in web mapping. Raster dominates many environmental sciences\n    partially because of the reliance on remote sensing data.\n\n## Vector Data\n\nThe geographic vector data model is based on points located within a\ncoordinate reference system (<a class='glossary' title='A CRS defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a>). Points can represent\nself-standing features (e.g., the location of a bus stop) or they can be\nlinked together to form more complex geometries such as lines and\npolygons.\n\nThe {**sf**} package provides classes for geographic vector data and a\nconsistent command line interface to important low-level libraries for\ngeocomputation:\n\n- <a class='glossary' title='The Geospatial Data Abstraction Library (GDAL) is a computer software library for reading and writing raster and vector geospatial data formats (e.g. shapefile), and is released under the permissive X/MIT style free software license by the Open Source Geospatial Foundation. As a library, it presents a single abstract data model to the calling application for all supported formats. (Wikipedia)'>GDAL</a>, for reading, writing and manipulating a wide range\nof geographic data formats, covered in [@XXXChapter8]. See: [GDAL](https://gdal.org/en/stable/) [@rouault-2025]. \n- <a class='glossary' title='PROJ is a generic coordinate transformation software that transforms geospatial coordinates from one coordinate reference system (CRS) to another. This includes cartographic projections as well as geodetic transformations. PROJ is released under the X/MIT open source license.'>PROJ</a>, a powerful library for coordinate system transformations, which\nunderlies the content covered in [@XXXChapter7]. See: [PROJ](https://proj.org/en/stable/) [@evenden-2024]. \n- <a class='glossary' title='GEOS (Graphical Environment Operating System) is a C/C++ library for computational geometry with a focus on algorithms used in geographic information systems (GIS) software. It implements the OGC Simple Features geometry model and provides all the spatial functions in that standard as well as many others. GEOS is open source software available under the terms of GNU Lesser General Public License (LGPL).'>GEOS</a>, a planar geometry\nengine for operations such as calculating buffers and centroids on data\nwith a projected <a class='glossary' title='A CRS defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a>, covered in [@XXXChapter5]. See [GEOS](https://libgeos.org/) [@geoscontributors-2024]. \n- <a class='glossary' title='S2 is a spherical geometry engine written in C++ developed by Google. Unlike traditional geographic information systems, which represent data as flat two-dimensional projections (similar to an atlas), the S2 library represents all data on a three-dimensional sphere (similar to a globe).'>S2</a>, a spherical geometry\nengine written in C++ developed by Google, via the {**s2**} package, covered\nin @XXXSection2-2-9 and in @XXXChapter7. See: [S2](http://s2geometry.io/) [@s2-geometry-contributors-2025].\n\n\nInformation about these interfaces is printed by {**sf**} the first time the package is loaded. The message tells us the versions of linked GEOS, GDAL and PROJ libraries (these vary between computers and over time) and whether or not the S2 interface is turned on. --- Since {**sf**} version 1.0.0, launched in June 2021, [s2 functionality is now used by default](https://r-spatial.org/r/2020/06/17/s2.html) on geometries with geographic (longitude/latitude) coordinate systems.\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-loaded-interfaces}\n: Print message about interfaces by loading {**sf**}\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::library(sf) # attach package\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::detach(\"package:sf\", unload=TRUE) ## return previous status\n```\n:::\n\n\n\n\n\n::::\n:::::\n\nA neat feature of {**sf**} is that you can change the default geometry engine used on unprojected data: ‘switching off’ S2 can be done with the command `sf::sf_use_s2(FALSE)`, meaning that the planar geometry engine GEOS will be used by default for all geometry operations, including geometry operations on unprojected data.\n\n### Introduction to Simple Features\n\n<a class='glossary' title='Simple Features, officially known as Simple Feature Access (ISO 19125), is a set of standards that specify a common storage and access model for geographic features, primarily composed of two-dimensional geometries like points, lines, polygons, and others. These standards are formalized by both the Open Geospatial Consortium (OGC) and the International Organization for Standardization (ISO). Simple features is a hierarchical data model that represents a wide range of geometry types. Of 18 geometry types supported by the specification, only seven are used in the vast majority of geographic research: POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, GEOMETRYCOLLECTION.'>Simple features</a> is a hierarchical data model that represents a wide range of geometry types. Of 18 geometry types supported by the specification, only seven are used in the vast majority of geographic research (see @fig-02-sf-classes); these core geometry types are fully supported by the R package {**sf**}.\n\n***\n\n![Simple feature types fully supported by {sf}.](img/02-sf-classes.png){#fig-02-sf-classes \nfig-alt=\"The picture shows a square surrounded by six other squares. Three of the squares contain a geometric object titled POINT, LINESTRING, and POLYGON. Three other squares contain two identical geometric objects titles MULTIOPOINT, MULTILINESTRING, AND MULTIPOLYGON. All these six squares have a connection to the centered square called GEOMETRYCOLLECTION containing all the different objects of the six peripheral squares.\" fig-align=\"center\" \nwidth=\"70%\"}\n\n***\n\n{**sf**} provides the same functionality (and more) previously provided in three (now deprecated) packages: \n\n- {**sp**} for data classes\n- {**rgdal**} for data read/write via an interface to GDAL and PROJ and \n- {**rgeos**} for spatial operations via an interface to GEOS.\n\n::: {.callout-note #nte-02-dprecated-packages}\n###### Deprecated packages & the history of the R-spatial ecosystem\n\nThis detailed infos (together with the history of the R-spatial ecosystem provided in Chapter 1 of the book) I would have needed earlier. When I started to learn spatial data science (one month ago, December 2024) I was confused about the many different packages with similar functionality.\n:::\n\nsf’s functionality is well documented on its website at [r-spatial.github.io/sf/](r-spatial.github.io/sf/) which contains seven vignettes. \n\n::: {.callout-important #imp-02-sf-definition}\n###### Simple feature objects \n\nSimple feature objects in R are stored in a data frame, with geographic data occupying a special column, usually named ‘geom’ or ‘geometry’. Simple features are, in essence, data frames with a spatial extension.\n:::\n\n\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-inspect-sf-classes}\n: Inspect {**sf**} classes, plotting, summary, and subsetting\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Inspect data\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-inspect-sf-world-data}\n: Inspect class and column names of `world`\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"world\", package = \"spData\")\nbase::class(world)\nbase::names(world)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n#>  [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n#>  [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"\n```\n\n\n:::\n:::\n\n\n\n\n\n***\n\nThe contents of the `geom` column give {**sf**} objects their spatial powers: `world$geom` is a ‘list column’ that contains all the coordinates of the country polygons.\n\n\n::::\n:::::\n\n\n###### Plot data\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-plot-sf-world-data}\n: Plot `world` data\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf:::plot.sf(world) # plot produces only the first 9 attributes (1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: plotting the first 9 out of 10 attributes; use max.plot = 10 to plot\n#> all\n```\n\n\n:::\n\n```{.r .cell-code}\nsf:::plot.sf(world, max.plot = 10) # 11 cols but 'geom' does not count as attribute (2)\nsf:::plot.sf(world, max.plot = Inf) # plot all availabe attributes (3)\n```\n\n::: {.cell-output-display}\n![Map of the world using the {**sf**} package, with a facet for each attribute.](02-geographic-data_files/figure-html/fig-02-plot-sf-world-data-1.png){#fig-02-plot-sf-world-data-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Map of the world using the {**sf**} package, with a facet for each attribute.](02-geographic-data_files/figure-html/fig-02-plot-sf-world-data-2.png){#fig-02-plot-sf-world-data-2 width=672}\n:::\n:::\n\n\n\n\n\n***\n\nInstead of creating a single map by default for geographic objects, as most GIS programs do, `plot()`ing `sf` objects results in a map for each variable in the datasets. This behavior can be useful for exploring the spatial distribution of different variables.\n\nIf you attach the {**sf**} package with `library(sf)` then `plot(world)` would have worked. But it is not the `base::plot()` function as errors in line 2 and 3 would show. `plot()` is a generic function that is extended by other packages. {**sf**} contains the non-exported (hidden from users most of the time and therefore with three columns prefixed) `sf:::plot.sf()` function which is called behind the scenes.\n\n\n::::\n:::::\n\n###### Summary\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-summary}\n: Treating sf objects as data frames\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::summary(world[\"lifeExp\"]) # infos about the 'geom' column \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     lifeExp                 geom    \n#>  Min.   :50.62   MULTIPOLYGON :177  \n#>  1st Qu.:64.96   epsg:4326    :  0  \n#>  Median :72.87   +proj=long...:  0  \n#>  Mean   :70.85                      \n#>  3rd Qu.:76.78                      \n#>  Max.   :83.59                      \n#>  NA's   :10\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::summary(world$lifeExp) # no infos about the 'geom' column\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n#>   50.62   64.96   72.87   70.85   76.78   83.59      10\n```\n\n\n:::\n:::\n\n\n\n\n\n***\n\nTreating geographic objects as regular data frames with spatial powers has many advantages, especially if you are already used to working with data frames. The commonly used `summary()` function, for example, provides a useful overview of the variables within the world object.\n::::\n:::::\n\n###### Subsetting\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-subsetting}\n: Subsetting `sf` object with base R and {dplyr}\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld[1:2, 1:3] # base R subsetting\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.28799 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#>   iso_a2 name_long continent                           geom\n#> 1     FJ      Fiji   Oceania MULTIPOLYGON (((-180 -16.55...\n#> 2     TZ  Tanzania    Africa MULTIPOLYGON (((33.90371 -0...\n```\n\n\n:::\n\n```{.r .cell-code}\nworld |> # tidyverse subsetting\n    dplyr::slice(1:2) |>\n    dplyr::select(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Simple feature collection with 2 features and 3 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -18.28799 xmax: 180 ymax: -0.95\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 2 × 4\n#>   iso_a2 name_long continent                                                geom\n#>   <chr>  <chr>     <chr>                                      <MULTIPOLYGON [°]>\n#> 1 FJ     Fiji      Oceania   (((-180 -16.55522, -179.9174 -16.50178, -179.7933 …\n#> 2 TZ     Tanzania  Africa    (((33.90371 -0.95, 31.86617 -1.02736, 30.76986 -1.…\n```\n\n\n:::\n:::\n\n\n\n\n\n\n***\n\nSubsetting is another example where `sf` objects are treating as normal data frames. The output shows two major differences compared with a regular data.frame: \n\n- the inclusion of additional geographic metadata (Geometry type, Dimension, Bounding box and coordinate reference system information), and \n- the presence of a ‘geometry column’, here named \"geom\".\n\nBase R and tidyverse subsetting yield the same result, but with slightly different formatting of the 'geom' column.\n::::\n:::::\n\n###### Class of 'geom' column\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-geom-class}\n: Class of the 'geom' column and of one entry of the 'geom' column\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::class(world) # class of sf object (sf)\nbase::class(world$geom) # class of 'geom' column (sfc)\nbase::class(world$geom[[1]]) # class of first entry of 'geom' (sfg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n#> [1] \"sfc_MULTIPOLYGON\" \"sfc\"             \n#> [1] \"XY\"           \"MULTIPOLYGON\" \"sfg\"\n```\n\n\n:::\n:::\n\n\n\n\n\n***\n\nHere you can see the hierarchy of the three object types in the {**sf**} universe. I explain it in reverse order, starting with the lowest level:\n\n- **sfg (Simple Feature Gemometry)** is the lowest unit; it has only coordinates (according to the [well-known text](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry) (<a class='glossary' title='Well-known text (WKT) is a text markup language for representing vector geometry objects in spatial analysis. WKT is used to mark geometric objects together to signify the same attribute, such as combining multiple points to represent a single entity like a university campus.'>WKT</a>) standard)\n- **sfc (Simple Feature Gemometry Collection)** is a set of sfg's, plus - crucially! - information about interpretation of the coordinate reference system / are the coordinates in meters, or degrees? plane or sphere? if sphere, which one? this is highly standardized stuff, often described in terms of <a class='glossary' title='EPSG stands for European Petroleum Survey Group, which is now known as the Geomatics Committee of the International Association of Oil and Gas Producers (IOGP). This organization maintains a database of coordinate system information, including datums, projections, and transformations, which is widely used in geographic information systems (GIS) for identifying and transforming coordinate reference systems. The EPSG Geodetic Parameter Dataset (https://epsg.org/) is available as a free download and serves as a global resource for coordinate system and transformation information.'>EPSG</a> codes ([EPSG Geodetic Parameter Dataset](https://epsg.org/home.html)).\n- **sf (Simple Feature)** is a sfc geometry with data columns, in addition to the geometry.\n\n::::\n:::::\n\n\n:::\n\n::::\n:::::\n\n### Why simple features?\n\nSimple features is a widely supported data model that underlies data structures in many <a class='glossary' title='GIS stands for Geographic Information System, which is a computer system designed to capture, store, manage, analyze, and display all types of geographical data. It allows users to visualize and analyze location-based data, helping organizations make informed decisions by identifying patterns and relationships in spatial data. GIS technology includes hardware, software, and data, and it often involves human users, procedures, and workflows to effectively manage and utilize geographic information.'>GIS</a> applications including [QGIS](https://qgis.org/) and [PostGIS](https://postgis.net/).\n\nThere are numerous advantages using the {**sf**} package:\n\n- Fast reading and writing of data\n- Enhanced plotting performance\n- `sf` objects can be treated as data frames in most operations\n- `sf` function names are relatively consistent and intuitive (all begin with `st_`)\n- `sf` functions can be combined with the |> operator and works well with the {**tidyverse**} collection of R packages.\n\n`sf::st_read()` vs. `sf::read_sf()` are good examples to show and compare the support for the {**tidyverse**} pckages. \n\n-   `sf::st_read()` emits verbose messages and returns the file content\n    stored in a base R `data.frame`.\n-   `sf::read_sf()` silently returns data as a tidyverse `tibble`.\n\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-compare-df-tib}\n: Compare `sf::st_read()` with `sf::read_sf()`\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_dfr = sf::st_read(system.file(\"shapes/world.gpkg\", package = \"spData\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Reading layer `world' from data source \n#>   `/Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/library/spData/shapes/world.gpkg' \n#>   using driver `GPKG'\n#> Simple feature collection with 177 features and 10 fields\n#> Geometry type: MULTIPOLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: -180 ymin: -89.9 xmax: 180 ymax: 83.64513\n#> Geodetic CRS:  WGS 84\n```\n\n\n:::\n\n```{.r .cell-code}\nworld_tbl = sf::read_sf(system.file(\"shapes/world.gpkg\", package = \"spData\"))\nbase::class(world_dfr) # base data.frame\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::class(world_tbl) # tidyverse tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n\n***\n\nData files from the {**spData**} package are located in the folder \"shapes\" inside the {**spData**} package folder.This can be detected manually in the operating systems by\nopening the folder \"spData\" for the {**spData**} package. To get the\nfile path one has to use the `base::system.file()` function with the\nappropriate package name and providing the path to the file inside this\npackage: `system.file(\"shapes/world.gpkg\", package = \"spData\")`.\n\n\n\n::::\n:::::\n\n\n::: {.callout-note #nte-importance-sf}\n###### {**sf**} is now the go-to package for analysis of spatial vector data in R\n \n{**spatstat**}, a package ecosystem which provides numerous functions for spatial statistics, and {**terra**} both have vector geographic data classes, but neither has the same level of uptake as {**sf**} does for working with vector data. Many popular packages build on {**sf**}.\n:::\n\n### Basic Maps\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-sf-basic-maps}\n: Basic maps created with {sf}\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Multi-panel plot\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-multi-panel-plot}\n: Multi-panel plot with {sf}\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf:::plot.sf(world[3:6])\n```\n\n::: {.cell-output-display}\n![A multi-panel plot with {**sf**} creates one sub-plot for each variable of the object.](02-geographic-data_files/figure-html/fig-02-sf-multi-panel-plot-1.png){#fig-02-sf-multi-panel-plot width=672}\n:::\n:::\n\n\n\n\n\n\n::::\n:::::\n\n\n###### Single plot\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-single-plot}\n: Single plot with {sf}\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf:::plot.sf(world[\"pop\"])\n```\n\n::: {.cell-output-display}\n![If the object to be plotted with {sf} has a single variable, then a legend with a continuous color is produced.](02-geographic-data_files/figure-html/fig-02-sf-single-plot-1.png){#fig-02-sf-single-plot width=672}\n:::\n:::\n\n\n\n\n\n::::\n:::::\n\n###### Fixed colors\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-fixed-color-plot}\n: Plot with {sf} with fixed country and border colors\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsf:::plot.sf(world[\"pop\"], col = \"lightblue\", border = \"black\")\n```\n\n::: {.cell-output-display}\n![You can set fixed colors in the `sf::plot.sf()` commands with `col` and `border` arguments.](02-geographic-data_files/figure-html/fig-02-sf-fixed-color-plot-1.png){#fig-02-sf-fixed-color-plot width=672}\n:::\n:::\n\n\n\n\n\n::::\n:::::\n\n\n:::\n\n::::\n:::::\n\nThere are various ways to modify maps with {**sf**}’s plot() method. Because {**sf**} extends base R plotting methods, `graphics::plot()`’s arguments work with {**sf**} objects (see `?graphics::plot` and `?par` for information on arguments.)\n\n\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-sf-adding-plot-layers}\n: Adding different layers to plot output of `sf` objects\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### filters & combining\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-filter-and-combine}\n: Numbered R Code Title\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"world\", package = \"spData\") # get world data\n\nbase::library(sf) |> base::suppressPackageStartupMessages() # load {sf}\n\nasia <-  world |> \n    dplyr::filter(continent == \"Asia\") |> # (1)\n    sf::st_union()\n\nplot(world[\"pop\"], reset = FALSE)\nplot(asia, add = TRUE, col = \"red\")\n\ndetach(\"package:sf\", unload = TRUE) # return to previous state, unload {sf}\n```\n\n::: {.cell-output-display}\n![Plot of Asia added as a layer on top of countries worldwide.](02-geographic-data_files/figure-html/fig-02-sf-filter-and-combine-1.png){#fig-02-sf-filter-and-combine width=672}\n:::\n:::\n\n\n\n\n\n***\n\nPlots are added as layers to existing images by setting `add = TRUE`. Line (1) in the above code chunk filters countries in Asia and combines them in line (2) into a single feature.\n\nWe can now plot the Asian continent over a map of the world. Note that the first plot (line (3)) must only have one facet for `add = TRUE` to work. If the first plot has a key (legend), `reset = FALSE` must be used.\n::::\n:::::\n\n\n###### unprojected\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-overlay-circles-unprojected}\n: Overlay circles representing country population on a world map (unprojected version)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::library(sf) |> base::suppressPackageStartupMessages() # load {sf}\n\nplot(world[\"continent\"], reset = FALSE)                    # (1)\ncex = base::sqrt(world$pop) / 10000                        # (2)\nworld_cents = sf::st_centroid(world, of_largest = TRUE)    # (3)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: st_centroid assumes attributes are constant over geometries\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(sf::st_geometry(world_cents), add = TRUE, cex = cex)  # (4)\n\ndetach(\"package:sf\", unload = TRUE) # return to previous state, unload {sf}\n```\n\n::: {.cell-output-display}\n![Overlaying circles, whose diameters (set with `cex =`) represent country populations, on a map of the world. Unprojected version](02-geographic-data_files/figure-html/fig-02-sf-overlay-circles-unprojected-1.png){#fig-02-sf-overlay-circles-unprojected width=672}\n:::\n:::\n\n\n\n\n\n***\n\nThe code above uses the function `sf::st_centroid()` to convert one geometry type (polygons) to another (points) (see @XXXChapter5), the aesthetics of which are varied with the `cex` argument.\n\nThe `sf::st_centroid()` function (line 3) produced: *'Warning: st_centroid assumes attributes are constant over geometries'*. \n\n> \"The reason for this is that the dataset contains variables with values that are associated with entire polygons … meaning they are not associated with a POINT geometry replacing the polygon.\" [@pebesma-2023, chapter 5]\n\n\n::::\n:::::\n\n\n###### projected\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-overlay-circles-projected}\n: Overlay circles representing country population on a world map (projected version)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"world\", package = \"spData\")\n\nbase::library(sf) |> base::suppressPackageStartupMessages() # load {sf}\n\nworld_proj = sf::st_transform(world, \"+proj=eck4\")                                   # (1)\nworld_cents = sf::st_centroid(world_proj, of_largest_polygon = TRUE)                 # (2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: st_centroid assumes attributes are constant over geometries\n```\n\n\n:::\n\n```{.r .cell-code}\ngraphics::par(mar = c(0, 0, 0, 0))                                                   # (3)\nplot(world_proj[\"continent\"], reset = FALSE, main = \"\", key.pos = NULL)              # (4)\ng = sf::st_graticule()                                                               # (5)\ng = sf::st_transform(g, crs = \"+proj=eck4\")                                          # (6)\nplot(g$geometry, add = TRUE, col = \"lightgray\")                                      # (7)\ncex = base::sqrt(world$pop) / 10000                                                  # (8)\nplot(sf::st_geometry(world_cents), add = TRUE, cex = cex, lwd = 2, graticule = TRUE) # (9)\n\ndetach(\"package:sf\", unload = TRUE) # return to previous state, unload {sf}\n```\n\n::: {.cell-output-display}\n![Overlaying circles, whose diameters (set with `cex =`) represent country populations, on a map of the world. Projected version](02-geographic-data_files/figure-html/fig-02-sf-overlay-circles-projected-1.png){#fig-02-sf-overlay-circles-projected width=672}\n:::\n:::\n\n\n\n\n\n***\n\nFor the above code I used the [script 02-contplot.R](https://github.com/geocompx/geocompr/blob/main/code/02-contpop.R). There are new code lines to change the unprojected to a projected figure that I do not yet understand fully.\n\n::::\n:::::\n\n:::\n\nIn all code chunks of this code collection I had to attach {**sf**} because the `sf:plot.sf(`) commands did not work. I received the error message '*Error in if (ncol(x) == 1) { : argument is of length zero*'. After changing the original code of the function to `if (isTRUE(x) && ncol(x) == 1)` I received other errors. Finally I gave up and used the standard `base::library(sf)`. \n\n::::\n:::::\n\n\n{**sf**}’s plot method also has arguments specific to geographic data. `expandBB`, for example, can be used to plot an `sf` object in context: it takes a numeric vector of length four that expands the bounding box of the plot relative to zero in the following order: bottom, left, top, right. This is used in the following code to plot India in the context of its giant Asian neighbors, with an emphasis on China to the east.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-using-expandBB}\n: Using `expandBB` argument to plot an `sf` object in context\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### no labels\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-plot-expandBB-no-labels}\n: Creating context by plotting with the `expandBB` argument (without labels)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::library(sf) |> base::suppressPackageStartupMessages() # load {sf}\n\nindia <- world |> \n    dplyr::filter(name_long == \"India\")\nworld_asia <- world |> \n    dplyr::filter(continent == \"Asia\")\n\nplot(sf::st_geometry(india), expandBB = c(-0.2, 0.5, 0, 1), col = \"gray\", lwd = 3)\nplot(sf::st_geometry(world_asia), add = TRUE)\n\ndetach(\"package:sf\", unload = TRUE) # return to previous state, unload {sf}\n```\n\n::: {.cell-output-display}\n![India in context, demonstrating the `expandBB` argument (without labels).](02-geographic-data_files/figure-html/fig-02-sf-plot-expandBB-no-labels-1.png){#fig-02-sf-plot-expandBB-no-labels width=672}\n:::\n:::\n\n\n\n\n\n\n::::\n:::::\n\n\n\n###### with labels\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-plot-expandBB-with-labels}\n: Creating context by plotting with the `expandBB` argument (with labels)\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutils::data(\"world\", package = \"spData\")\nbase::library(sf) |> base::suppressPackageStartupMessages() # load {sf}\n\nindia <- world |> \n    dplyr::filter(name_long == \"India\")\nworld_asia <- world |> \n    dplyr::filter(continent == \"Asia\")\nindchi  <-  \n    world_asia[grepl(\"Indi|Chi\", world_asia$name_long), ]\nindchi_coords <- \n    sf::st_centroid(indchi) |> \n    sf::st_coordinates()\n\nold_par = graphics::par(mar = rep(0, 4))\n\nplot(sf::st_geometry(india), expandBB = c(-0.2, 0.5, 0, 1), col = \"gray\", lwd = 3)\nplot(world_asia[0], add = TRUE)\nterra::text(indchi_coords[, 1], indchi_coords[, 2], indchi$name_long)\n\ngraphics::par(old_par)\n\ndetach(\"package:sf\", unload = TRUE) # return to previous state, unload {sf}\n```\n\n::: {.cell-output-display}\n![India in context, demonstrating the `expandBB` argument (with labels).](02-geographic-data_files/figure-html/fig-02-sf-plot-expandBB-with-labels-1.png){#fig-02-sf-plot-expandBB-with-labels width=672}\n:::\n:::\n\n\n\n\n\n\n::::\n:::::\n\n:::\n\nNote the use of `lwd` (linewidth) to emphasize India in the plotting code. See @XXXChapter9-2 for other visualization techniques for representing a range of geometry types, the subject of the next section.\n\n::::\n:::::\n\n### Geometry Types\n\nGenerally, well-known binary (<a class='glossary' title='Well-known binary (WKB) is a format for representing geographical and geometrical data in a binary form. It is designed to be platform-independent and is typically used for transporting geometry data between systems or programs. WKB uses 1-byte unsigned integers, 4-byte unsigned integers, and 8-byte double-precision numbers (IEEE 754 format).'>WKB</a>) or well-known text (<a class='glossary' title='Well-known text (WKT) is a text markup language for representing vector geometry objects in spatial analysis. WKT is used to mark geometric objects together to signify the same attribute, such as combining multiple points to represent a single entity like a university campus.'>WKT</a>) are the standard encoding for simple feature geometries. \n\n- **WKB** representations are usually hexadecimal strings easily readable for computers. This is why GIS and spatial databases use WKB to transfer and store geometry objects. \n- **WKT**, on the other hand, is a human-readable text markup description of simple features. Both formats are exchangeable.\n\n### The sf class\n\nSimple features consist of two main parts: geometries and non-geographic attributes. @fig-02-sf-diagram shows how an `sf` object is created – geometries come from an `sfc` object, while attributes are taken from a `data.fram`e or `tibble`. \n\n![Building blocks of `sf` objects](img/02-sfdiagram.png){#fig-02-sf-diagram \nfig-alt=\"alt-text\" fig-align=\"center\" \nwidth=\"100%\"}\n\nMore about building sf geometries from scratch see @XXXChapter2-2-6 and @XXXChapter2-2-7.\n\n::: {.my-code-collection}\n:::: {.my-code-collection-header}\n::::: {.my-code-collection-icon}\n:::::\n:::::: {#exm-02-sf-builing-blocks}\n: Creation and Class of sf Building Blocks\n::::::\n\n::::\n\n::::{.my-code-collection-container}\n\n::: {.panel-tabset}\n\n###### Creation\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-building-block-creation}\n: Building blocks of `sf` objects\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(lnd_point = sf::st_point(c(0.1, 51.5))   )              # (1) sfg object\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT (0.1 51.5)\n```\n\n\n:::\n\n```{.r .cell-code}\n(lnd_geom = sf::st_sfc(lnd_point, crs = \"EPSG:4326\"))    # (2) sfc object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Geometry set for 1 feature \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 0.1 ymin: 51.5 xmax: 0.1 ymax: 51.5\n#> Geodetic CRS:  WGS 84\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> POINT (0.1 51.5)\n```\n\n\n:::\n\n```{.r .cell-code}\n(\n    lnd_attrib = base::data.frame(                       # (3) data.frame object\n      name = \"London\",\n      temperature = 25,\n      date = base::as.Date(\"2023-06-21\")\n    )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>     name temperature       date\n#> 1 London          25 2023-06-21\n```\n\n\n:::\n\n```{.r .cell-code}\n(lnd_sf = sf::st_sf(lnd_attrib, geometry = lnd_geom))    # (4) sf object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Simple feature collection with 1 feature and 3 fields\n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 0.1 ymin: 51.5 xmax: 0.1 ymax: 51.5\n#> Geodetic CRS:  WGS 84\n#>     name temperature       date         geometry\n#> 1 London          25 2023-06-21 POINT (0.1 51.5)\n```\n\n\n:::\n:::\n\n\n\n\n\n***\n\n- **Line 1**: The coordinates were used to create the simple feature geometry (sfg). \n- **Line 2**: The geometry was converted into a simple feature geometry column (sfc), with a <a class='glossary' title='A CRS defines how locations on the Earth’s surface are represented in a two-dimensional plane. This is essential for accurate mapping and spatial analysis. CRSs are often defined using the PROJ.4 notation, which is a standard way to describe coordinate systems. CRSs can also be identified using EPSG codes, which are unique identifiers for different coordinate systems.'>CRS</a>. \n- **Line 3**: Attributes were stored in a data.frame. \n- **Line 4**: The data.frame was combined with the sfc object. The results in an sf object.\n\nThe result shows that `sf` objects actually have two classes, `sf` and `data.frame`. Simple features are simply data frames (square tables), but with spatial attributes stored in a list column, usually called geometry or geom, as described in @imp-02-sf-definition. This duality is central to the concept of simple features: most of the time a `sf` can be treated as and behaves like a data.frame. **Simple features are, in essence, data frames with a spatial extension.**\n\n::::\n:::::\n\n\n\n###### Classes\n\n:::::{.my-r-code}\n:::{.my-r-code-header}\n:::::: {#cnj-02-sf-classes}\n: Classes of sf Building Blocks\n::::::\n:::\n::::{.my-r-code-container}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase::class(lnd_point)  # sfg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"XY\"    \"POINT\" \"sfg\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::class(lnd_geom)   # sfc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sfc_POINT\" \"sfc\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::class(lnd_attrib) # data.frame\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nbase::class(lnd_sf)     # sf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"sf\"         \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n\n\n***\n\nDepending of the created geometry type POINT can be replaced by LINESTRING, POLYGON, MUTLIPOINT, MULTILINESTRING, MULTIPOLYGON. It is most often the case that the objects are of identical type. In case of a mix of types or an empty set, POINT (or any of the other mentioned gemoetries) are set to the superclass GEOMETRY.\n\n::::\n:::::\n\n:::\n\n::::\n:::::\n\n\n@fig-02-building-blocks-sf shows --- as a kind of summary --- the different `sf` objects in their contexts [Picture taken from @sadler-2018]. \n\n\n![Building Blocks of sf objects](img/02-building-blocks-sf-objects.jpg){#fig-02-building-blocks-sf \nfig-alt=\"alt-text\" fig-align=\"center\" \nwidth=\"100%\"}\n\n\n",
    "supporting": [
      "02-geographic-data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}