---
execute:
  cache: true
  echo: true
  code-fold: true
---

# Making Maps with R {#sec-chap09}

```{r}
#| label: setup
#| results: hold
#| include: false

base::source(file = "R/helper.R")
ggplot2::theme_set(ggplot2::theme_bw())

```

## Table of content for chapter 09 {.unnumbered}

:::::: {#obj-chap03}
::::: my-objectives
::: my-objectives-header
Chapter section list
:::

::: my-objectives-container

1. **Introduction** (@sec-09-introduction)
2. **Static Maps** are the most common type of visual output from geocomputation. This is therefore the longest and most detailed part of this chapter (@sec-09-static-maps).
    - **Scales** control how the values are represented on the map and in the legend, and they largely depend on the selected visual variable (@sec-09-scales). We can distinguish between interval (@sec-09-interval-scales), continuous (@sec-09-continuous-scales) and categorical scales (@sec-09-categorical-scales) applying categorical, sequential or diverging palettes (@sec-09-scale-summary).
    - **Legends** have a certain title, position, orientation to place it on the graphics. But you can also disable legend (@sec-09-legends).
    - **Layouts** refer to the combination of all map elements into a cohesive map (@sec-09-layouts).
    - **Faceted maps** are composed of many maps arranged side-by-side, and sometimes stacked vertically. Facets enable the visualization of how spatial relationships change with respect to another variable, such as time (@sec-09-faceted-maps). They can also used with special parameters for animated maps (@sec-09-animated-maps).
    - **Inset maps** are smaller maps rendered within or next to the main map (@sec-09-inset-maps). It is a complex chapter which uses details of the {**grid**} package like `grid::viewport()`, `grid::grid.newpage()` and the `sf::bbox()` function to return the bounding of a simple feature (set). As I do not need inset maps at the moment for my own research I skipped this section.
3. **Animated maps** show how spatial distributions of variables change (e.g., over time) sometimes better than tiny faceted maps (@sec-09-animated-maps).
4. **Interactive maps** is the next level to explore data. Interactivity can take many forms: Starting with interactive labels through pop-ups when you hover over the region or click with the mouse, continuing with the ability to pan around and zoom into any part of a geographic dataset overlaid on a ‘web map’ to show context to the more advanced level of the ability to tilt and rotate maps (@sec-09-interactive-maps).
:::
:::::
::::::

## Introduction {#sec-09-introduction}

I am following here Chapter 9 [Making Maps with
R](https://r.geocompx.org/adv-map) respectively chapter 8 of the printed book 2nd edition, explaining mainly the use of
{**tmap**}. In addition to the example and code demonstrations I will
also use my own `r glossary("WHR")` dataset.

To facilitate working with the WHR dataset I have joined the ladder
score values in a new column "WHR" with the `world` dataset of
{**tmap**} and stored as `world_whr_2024.rds` in "data/chapter09"

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-join-world-whr-dataset}
: Join WHR ladder scores with {**tmap**} World dataset
:::
::::

::: my-r-code-container
```{r}
#| label: join-world-whr-dataset

my_create_folder("data/chapter09")

whr_2024 <-  base::readRDS("data/chapter09/whr_final_2024.rds") |> 
    dplyr::select(iso3, ladder_score) |> 
    dplyr::rename(WHR = ladder_score)

World <- tmap::World

world_whr_2024 <- dplyr::left_join(
    World,
    whr_2024,
    dplyr::join_by(iso_a3 == iso3)
)

my_save_data_file("chapter09", world_whr_2024, "world_whr_2024.rds")

dplyr::glimpse(world_whr_2024)
```
:::
::::::

## Static maps {#sec-09-static-maps}

Static maps are the most common type of visual output from geocomputation. They are usually stored in standard formats including `.png` and `.pdf` for graphical raster and vector outputs, respectively. Initially, static maps were the only type of maps that R could produce. Things have advanced very much in the last decade, and many map-making techniques, functions, and packages have been developed since then. However, despite the innovation of interactive mapping, static plotting was still the emphasis of geographic data visualization in R.

The generic `base::plot()` function is often the fastest way to create static maps from vector and raster spatial objects. Sometimes, simplicity and speed are priorities, especially during the development phase of a project, and this is where `base::plot()` excels. The base R approach is also extensible, with `base::plot()` offering dozens of arguments. Another approach is the {**grid**} package which allows low-level control of static maps. But these notes focus on {**tmap**} and emphasizes the essential aesthetic and layout options.

### {tmap} basics

:::::::::::::::::::: my-code-collection
::::: my-code-collection-header
::: my-code-collection-icon
:::

::: {#exm-09-tmap-basics}
: {**tmap**} basics
:::
:::::

:::::::::::::::: my-code-collection-container
::::::::::::::: panel-tabset
###### nz layers

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-nz-layers}
: New Zealand Layers
:::
::::

::: my-r-code-container
```{r}
#| label: fig-nz-layers
#| fig-cap: "New Zealand’s shape plotted with fill (left), border (middle) and fill and border (right) layers added using tmap functions."

# get nz data
nz <- spData::nz

# Add fill layer to nz shape
nz1 <- tmap::tm_shape(nz) +
  tmap::tm_fill() 
# Add border layer to nz shape
nz2 <- tmap::tm_shape(nz) +
  tmap::tm_borders() 
# Add fill and border layers to nz shape
nz3 <- tmap::tm_shape(nz) +
  tmap::tm_fill() +
  tmap::tm_borders()
  
tmap::tmap_arrange(nz1, nz2, nz3)
    

```
:::
::::::

###### whr world

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-world-with-layers}
: World countries layers
:::
::::

::: my-r-code-container
```{r}
#| label: fig-whr-world-with-layers
#| fig-asp: 0.5
#| echo: fenced 
#| fig-cap: "Shape of world countries plotted with fill and border layers added using tmap functions."


world_whr_2024 <- base::readRDS("data/chapter09/world_whr_2024.rds")

world_whr_2024 |> 
      tmap::tm_shape() +
      tmap::tm_fill() +
      tmap::tm_borders() +
      tmap::tm_crs("+proj=robin")
```
:::
::::::

###### Ladder scores

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-whr-ladder-scores}
: Numbered R Code Title
:::
::::

::: my-r-code-container
```{r}
#| label: fig-whr-ladder-scores
#| fig-asp: 0.4
#| echo: fenced 
#| fig-cap: "World Happiness Report Ladder scores"

# works better with Antarctica and earth_boundary = TRUE
tmap::tm_shape(world_whr_2024) +
tmap::tm_polygons("WHR") +
tmap::tm_crs("+proj=robin") +
# tmap::tm_title("World Happiness") +
tmap::tm_layout(
    earth_boundary = FALSE, 
    frame = FALSE
    )
```
:::
::::::
:::::::::::::::
::::::::::::::::
::::::::::::::::::::

### Map objects

Map objects can be stored as class `tmap` into the R memory. You can add
new shapes later with `+ tm_shape(new_obj)`

(The book example are not useful for my applications as it add raster
objects and uses geometry operations.)

### Visual variables

The plots in the previous section demonstrate tmap’s default aesthetic
settings. Gray shades are used for `tmap::tm_fill()` layers and a
continuous black line is used to represent lines created with
`tmap::tm_borders()`. Of course, these default values and other
aesthetics can be overridden.

-   `fill`: fill color of a polygon
-   `col`: color of a polygon border, line, point, or raster
-   `lwd`: line width
-   `lty`: line type
-   `size`: size of a symbol
-   `shape`: shape of a symbol

Additionally, you may customize the fill and border color transparency
using `fill_alpha` and `col_alpha`.

#### Fixed values

:::::::::::::::: my-code-collection
::::: my-code-collection-header
::: my-code-collection-icon
:::

::: {#exm-09-visualize-fixed-values}
: Visualize fixed aesthetic arguments on different layer types
:::
:::::

:::::::::::: my-code-collection-container
::::::::::: panel-tabset
###### New Zealand

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-visualize-fixed-nz-values}
: NZ: Visualize aesthetic arguments with fixed values
:::
::::

::: my-r-code-container
```{r}
#| label: fig-nz-visualize-values
#| fig-cap: "Impact of changing commonly used fill and border aesthetics to fixed values."

ma1 = tmap::tm_shape(nz) + tmap::tm_polygons(fill = "red")
ma2 = tmap::tm_shape(nz) + tmap::tm_polygons(fill = "red", fill_alpha = 0.3)
ma3 = tmap::tm_shape(nz) + tmap::tm_polygons(col = "blue")
ma4 = tmap::tm_shape(nz) + tmap::tm_polygons(lwd = 3)
ma5 = tmap::tm_shape(nz) + tmap::tm_polygons(lty = 2)
ma6 = tmap::tm_shape(nz) + tmap::tm_polygons(fill = "red", fill_alpha = 0.3,
                                 col = "blue", lwd = 3, lty = 2)
tmap::tmap_arrange(ma1, ma2, ma3, ma4, ma5, ma6)
```
:::
::::::

###### WHR

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-visualize-fixed-whr-values}
: WHR: Visualize aesthetic arguments with fixed values
:::
::::

::: my-r-code-container
```{r}
#| label: fig-whr-visualize-values
#| fig-cap: "Impact of changing commonly used fill and border aesthetics to fixed values."

wrld1 = tmap::tm_shape(world_whr_2024) + tmap::tm_polygons(fill = "red")
wrld2 = tmap::tm_shape(world_whr_2024) + tmap::tm_polygons(fill = "red", fill_alpha = 0.3)
wrld3 = tmap::tm_shape(world_whr_2024) + tmap::tm_polygons(col = "blue")
wrld4 = tmap::tm_shape(world_whr_2024) + tmap::tm_polygons(lwd = 3)
wrld5 = tmap::tm_shape(world_whr_2024) + tmap::tm_polygons(lty = 2)
wrld6 = tmap::tm_shape(world_whr_2024) + tmap::tm_polygons(fill = "red", fill_alpha = 0.3,
                                 col = "blue", lwd = 3, lty = 2)
tmap::tmap_arrange(wrld1, wrld2, wrld3, wrld4, wrld5, wrld6)
```
:::
::::::
:::::::::::
::::::::::::
::::::::::::::::

#### Variable values

Using variable values, e.g. values from a column of the dataset, is the essential technique to show colored country differences on a map. Other issues (choosing an appropriate color palette, adapting text and position of the legend etc.) are — seen from a general perspective — only details.

:::::::::::::::: my-code-collection
::::: my-code-collection-header
::: my-code-collection-icon
:::

::: {#exm-09-visualize-variable-values}
: Visualize variable aesthetic arguments on different layer types
:::
:::::

:::::::::::: my-code-collection-container
::::::::::: panel-tabset
###### New Zealand

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-visualize-nz-variables}
: NZ: Visualize aesthetic arguments with NZ variables
:::
::::

::: my-r-code-container
```{r}
#| label: fig-visualize-nz-variables
#| fig-cap: "Fill regions of New Zealand with values of column 'Land_area'"

tmap::tm_shape(nz) + tmap::tm_fill(fill = "Land_area")
```
:::
::::::

###### WHR

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-visualize-whr-variables}
: WHR: Visualize aesthetic arguments with WHR variables
:::
::::

::: my-r-code-container
```{r}
#| label: fig-visualize-whr-variables
#| fig-cap: "Fill countries of the world with well-being values of HPI and WHR"

well_being_HPI <- tmap::tm_shape(world_whr_2024) + tmap::tm_fill(fill = "well_being")
well_being_WHR <- tmap::tm_shape(world_whr_2024) + tmap::tm_fill(fill = "WHR")

tmap::tmap_arrange(well_being_HPI, well_being_WHR)
```

***

If you compare the well-being index from the Happiness Planet Index (`r glossary("HPI")`) and from the World Happiness Reports (`r glossary("WHR")`) you can see that the results are very similar. But there are some differences: For instance in countries with missing values, or Mexico, Colombia and Argentina have higher values in the WHR index. To understand these differences I would have to dive deeper in the different construction of the indexes.



:::
::::::
:::::::::::
::::::::::::
::::::::::::::::

Each visual variable has three related additional arguments, with suffixes of `.scale`, `.legend`, and `.free`. For example, the `tmap::tm_fill()` function has arguments such as `fill`, `fill.scale`, `fill.legend`, and `fill.free`. 

- The `.scale` argument determines how the provided values are represented on the map and in the legend (@sec-09-scales),
- The `.legend` argument is used to customize the legend settings, such as its title, orientation, or position (@sec-09-legends)
- The `.free` argument is relevant only for maps with many facets to determine if each facet has the same or different scale and legend.

### Scales {#sec-09-scales}

#### Setting breaks

Scales control how the values are represented on the map and in the
legend, and they largely depend on the selected visual variable. For
example, when our visual variable is `fill`, then `fill.scale` controls
how the colors of spatial objects are related to the provided values;
and when our visual variable is `size`, then `size.scale` controls how
the sizes represent the provided values.

By default, the used scale is `tmap::tm_scale()`, which selects the
visual settings automatically given by the input data type (factor,
numeric, and integer).

Let’s see how the scales work by customizing polygons’ fill colors.
Color settings are an important part of map design – they can have a
major impact on how spatial variability is portrayed.
    


    
::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-ID}
: Different color settings and scales for income variable
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### NZ


:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-color-nz-settings}
: Different break settings and color palettes for NZ medium income
:::
::::

::: my-r-code-container
```{r}
#| label: fig-nz-breaks
#| fig-cap: "Break settings. The results show (from top left to bottom right): default settings (= 'pretty' breaks), manual breaks, n breaks, and the impact of changing the palette."

nz_scale1 <- tmap::tm_shape(nz) + tmap::tm_polygons(fill = "Median_income")
nz_scale2 <- tmap::tm_shape(nz) + tmap::tm_polygons(fill = "Median_income",
                        fill.scale = tmap::tm_scale(breaks = c(0, 30000, 40000, 50000)))
nz_scale3 <- tmap::tm_shape(nz) + tmap::tm_polygons(fill = "Median_income",
                           fill.scale = tmap::tm_scale(n = 10))
nz_scale4 <- tmap::tm_shape(nz) + tmap::tm_polygons(fill = "Median_income",
                           fill.scale = tmap::tm_scale(values = "brewer.bu_gn"))

tmap::tmap_arrange(
  nz_scale1,
  nz_scale2,
  nz_scale3,
  nz_scale4
)



```
***

This figure shows four ways of splitting the input data values into a set of intervals.

-   **Top left**: The default setting uses ‘pretty’ breaks, e.g., rounds breaks into whole numbers where possible and spaces them evenly.
-   **Top right**: `breaks` allows you to manually set the breaks
-   **Bottom right**: `n` sets the number of bins into which numeric variables are
    categorized
-   **Bottom left**: `values` defines the color scheme, for example,
    `brewer.bu_gn`


::: {.callout-warning}
###### {tmap} version 4 has new names for color palettes

The value for the example color scheme is in the book `BuGn`. But this value results into a warning:
    
> [cols4all] color palettes: use palettes from the R package {**cols4all**}. Run `cols4all::c4a_gui()` to explore them. The old palette name "BuGn" is named "brewer.bu_gn". 
>
> Multiple palettes called "bu_gn" found: "brewer.bu_gn", "matplotlib.bu_gn". The first one, "brewer.bu_gn", is returned.
    
{**cols4all**} is a new R package for selecting color palettes, with a special orientation to include palettes for people with color vision deficiency. 
:::

:::
::::::

###### Standard breaks

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-settings-pretty-breaks}
: GDP per capita with standard ‘pretty’ breaks
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-settings-pretty-breaks
#| fig-cap: "GDP per capita with standard ('pretty') breaks" 

world_no_ata <- world_whr_2024 |> 
  dplyr::filter(name != "Antarctica")

tmap::tm_shape(world_no_ata) + 
  tmap::tm_polygons(
    fill = "gdp_cap_est",
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "bottom")
      )
  )


```
***

Because of it extraordinary GDP per capita value (200,000 US $) I have removed the uninhabited Antarctica from the map. It has a population of only 4490 people, supposedly researchers working in this huge area.



::::
:::::

###### Manual breaks

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-settings-manual-breaks}
: GDP per capita with breaks defined
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-settings-manual-breaks
#| echo: fenced
#| fig-asp: 0.5
#| fig-cap: "GDP per capita with breaks defined" 


tmap::tm_shape(world_whr_2024) + 
  tmap::tm_polygons(
      fill = "gdp_cap_est",
      fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      ),              
      fill.scale = tmap::tm_scale(
        breaks = c(0, 5000, 10000, 15000, 20000, 200000)
        )
      )

```
***

To differentiate better the lower end of the distribution I have chosen small interval breaks until 20,000 US\$ and put together all those countries that GDP per capita is higher than 20,000 US\$.

I contrast to the previous example I have additionally I have set the aspect ratio of the figure. (See the code chunk option `fig-asp: 0.5`.) This removes the white space above and below the figure.

::::
:::::

###### n breaks

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-settings-n-breaks}
: GDP per capita with number of breaks specified (n = 10)
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-settings-n-breaks
#| fig-asp: 0.7
#| fig-cap: "GDP per capita with a specified number of breaks (n = 10)" 

tmap::tm_shape(world_whr_2024) + 
  tmap::tm_polygons(
     fill = "gdp_cap_est",
     fill.scale = tmap::tm_scale(n = 10),
     fill.legend = tmap::tm_legend(
        title = "Estimated GDP per capita", 
        orientation = "landscape")
     )
```
***

If the data would have missing values I had to choose another color palette or tho change the default color for `NA`s. Otherwise the standard gray color for missing values (`NA`s) would be difficult to distinguish from the color of the lowest break (0-20,000).
::::
:::::





###### Color palette

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-choose-color-palette}
: Choosing another color palette
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-color-palette
#| fig-cap: "Different color palette" 
#| fig-asp: 0.5


world_no_ata <- world_whr_2024 |> 
  dplyr::filter(name != "Antarctica")

tmap::tm_shape(world_no_ata) + 
  tmap::tm_polygons(fill = "gdp_cap_est",
     fill.scale = tmap::tm_scale(
       values = "matplotlib.rainbow"
       ),
     fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "bottom")
      )
 )
  
```
***

In this example I haven chosen a color palette with different colors instead of just the same color with different saturation. The `matplotlib.rainbow` palette is very helpful to visually distinguish differences in the countries. It is much better suited than the standard "blues" or other gradient scale versions.

In this example you can't see the only red country Luxembourg with over 100,000 \$ GDP per capita, because it is too small. But you will see a tiny orange spot in Europe. This is Switzerland the only country slightly over 80,000 \$ GDP per capita. You will get a sightly better view if you click on this last figure to get a larger image.

::: {.callout-important}
###### Choose the desired color palette with the interactive {**shiny**} website calling `cols4all::ca4_gui()` from the console.
:::

::::
:::::

:::

::::
:::::


::: {.callout-tip}
###### Arguments work for other types of visual variables too

All of the above arguments (`breaks`, `n`, and `values`) also work for other types of visual variables. For example, `values` expects a vector of colors or a palette name for `fill.scale` or `col.scale`, a vector of sizes for `size.scale`, or a vector of symbols for `shape.scale`.
:::

#### Interval scales {#sec-09-interval-scales}

The `tmap::tm_scale_intervals()` function splits the input data values into a set of intervals. In addition to setting breaks manually, {**tmap**} allows users to specify algorithms to create breaks with the style argument automatically. The default is `tmap::tm_scale_intervals(style = "pretty")`, which rounds breaks into whole numbers where possible and spaces them evenly.

- **style = "pretty"**: default value, rounds breaks into whole numbers where possible and spaces them evenly.
- **style = "equal"**: divides input values into bins of equal range and is appropriate for variables with a uniform distribution (not recommended for variables with a skewed distribution as the resulting map may end up having little color diversity).
- **style = "quantile"**: ensures the same number of observations fall into each category (with the potential downside that bin ranges can vary widely).
- **style = "jenks"**: identifies groups of similar values in the data and maximizes the differences between categories.
- **style = "log10_pretty"**: a common logarithmic (the logarithm to base 10) version of the regular pretty style used for variables with a right-skewed distribution.

::: {.callout-note}
###### Origin of class interval computation

Although `style` is an argument of {**tmap**} functions, in fact it originates as an argument in `classInt::classIntervals()`. See the [help pages](https://r-spatial.github.io/classInt/reference/classIntervals.html) for {**classInt**) especially the article on [head/tail breaks](https://r-spatial.github.io/classInt/articles/headtailsR.html) (Pareto 80/20 rule).
:::


::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-09-setting-intervals}
: Setting intervals with algorithms via "styles"
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### NZ

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-nz-setting-intervals}
: Different interval scale methods using the `style` argument
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-nz-setting-intervals
#| fig-cap: "Different interval scale methods using the `style` argument"

tmap::tmap_options(
  legend.position = 
    tmap::tm_pos_in(pos.h = "left", pos.v = "top")
)


nz_int1 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(fill = "Median_income",
          fill.scale = tmap::tm_scale_intervals(style = "pretty")) +
  tmap::tm_credits('style = "pretty"', size = 1)

nz_int2 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(fill = "Median_income",
          fill.scale = tmap::tm_scale_intervals(style = "equal")) +
  tmap::tm_credits('style = "equal"', size = 1)

nz_int3 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(fill = "Median_income",
          fill.scale = tmap::tm_scale_intervals(style = "quantile")) +
  tmap::tm_credits('style = "quantile"', size = 1)

nz_int4 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(fill = "Median_income",
          fill.scale = tmap::tm_scale_intervals(style = "jenks")) +
  tmap::tm_credits('style = "jenks"', size = 1)

nz_int5 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Population",
    fill.scale = (
      tmap::tm_scale_intervals(
        style = "log10_pretty",
        values = "brewer.bu_pu"
        )
    ) 
  ) +
  tmap::tm_credits('style = \n"log10_pretty"', size = 1)


tmap::tmap_arrange(nz_int1, nz_int2, nz_int3, nz_int4, nz_int5)


```
***

Here I have added the interval style for each example as annotation. I couldn't find an annotation function, so I had used `tmap::tm_credits()`. 

Note also the different color palette in the last example `style = "log10_pretty"`. I have called `cols4all::c4a_gui()` from the console, set the number of colors to 3 and looked for a palette with blue and this reddish color at the high end (`brewer.bu_pu`).
::::
:::::


###### pretty

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-pretty}
: Set interval scale using `style = "pretty"`
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-pretty
#| fig-cap: "Set interval scale for WHR ladder scores using the standard `style = 'pretty'`."
#| fig-asp: 0.5


tmap::tm_shape(world_whr_2024) + 
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = tmap::tm_scale_intervals(
        style = "pretty",
        values = "matplotlib.rainbow"
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***

These are the standard intervals. The code line `fill.scale = tmap::tm_scale_intervals(style = "pretty")` wouldn't be necessary. It results in nice intervals from 1 to 8.

Choosing the "matplotlib.rainbow" color palette helps to distinguish the different categories. So you can see that the only two countries with a blueish color in Asia (Afghanistan) and in Africa (Sierra Leone). It is easy to see that Afghanistan is the most unhappiness country falling the worst category between 1 and 2 (value = 1.368), whereas Sierra Leone belongs to the somewhat better next category. Sierra Leone actually has a value of almost 3 (value = 2.998). This is the disadvantage of interval categories: Each country belongs to one category, but you can't see where they are positioned inside their categories.
::::
:::::

###### equal1

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-equal}
: Set interval scale using `style = "equal"`
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-equal
#| fig-cap: "Set interval scale for WHR ladder scores using `style = 'equal'`."
#| fig-asp: 0.5

tmap::tm_shape(world_whr_2024) + 
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = tmap::tm_scale_intervals(
        style = "equal",
        values = "matplotlib.rainbow"
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***

Here we get categories with ugly boundaries. It does not have an advantage to the better to interpret "pretty" solution.
::::
:::::

###### equal12

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-equal-12-breaks}
: Set interval scale using `style = "equal"` with 12 breaks
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-12-breaks
#| fig-cap: "Set interval scale for WHR ladder scores using the `style = 'equal'` with 12 breaks."
#| fig-asp: 0.5

tmap::tm_shape(world_whr_2024) + 
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = tmap::tm_scale_intervals(
        style = "equal",
        n = 12,
        values = "cols4all.friendly13"
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***

Again we have ugly boundaries for each category. But this time there is an advantage: The 12 categories give a more detailed picture, especially in the higher end of the `r glossary("cantril ladder")` scores.

But the set of interval is still not ideal: For instance the second worst category has no element in it and at the high end we have not enough differentiation.

The "cols4all.friendly13" scale has 13 different colors, but for me there are two colors a that hare difficult to distinguish. So I decided to go with just 12 colors.
::::
:::::

###### quantile

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-quantile}
: Set interval scale using `style = "quantile"` 
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-quantile
#| fig-cap: "Set interval scale for WHR ladder scores using `style = 'quantile'`."
#| fig-asp: 0.5

tmap::tm_shape(world_whr_2024) + 
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = tmap::tm_scale_intervals(
        style = "quantile",
        values = "cols4all.friendly13"
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***
This set of intervals gives a good rough picture of the WHR results: We have just 5 categories for 140 countries with ladder scores. In each category are placed 28 countries. So can we for instance decide the relative position of each country:

| Label     | Color               |
|-----------|---------------------|
| worst     | red colored countries |
| bad       | ochre / dark yellow colored countries |
| middle    | blue colored countries |
| good      | dark green colored countries |
| excellent | violet / purple colored countries |

Sure this is a very coarse classification but it gives an idea about the distribution of the happiness index in the world.
::::
:::::

###### quantile12

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-quantile}
: Set interval scale using `style = "quantile"` with 12 breaks
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-quantile12
#| fig-cap: "Set interval scale for WHR ladder scores using `style = 'quantile'`."
#| fig-asp: 0.5

tmap::tm_shape(world_whr_2024) + 
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = tmap::tm_scale_intervals(
        style = "quantile",
        values = "cols4all.friendly13",
        n = 12
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***

Because of the many colors the interpretation is not easy. But you get a good idea in which value regions are a concentration of countries. The two broad categories at both ends are necessary to get the same amount of countries as in the much thinner inner categories.
:::::
::::

###### log10 (pop)

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-log10}
: Set interval scale using `style = "log10_pretty"` for country populations
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-log10
#| fig-cap: "Set interval scale for WHR ladder scores using `style = 'log10_pretty'` for country populations"
#| fig-asp: 0.5

tmap::tm_shape(world_whr_2024) + 
  tmap::tm_polygons(
    fill = "pop_est",
    fill.scale = tmap::tm_scale_intervals(
        style = "log10_pretty",
        values = "cols4all.friendly13"
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***

This is not a sensible map. I think `style = 'log10_pretty'` is better suited for instance to show an individual income distribution where 1% of the people owns the overwhelming part of the wealth. Or other content with a similar very skewed distribution.


:::::
::::



:::

::::
:::::

#### Continuous scales {#sec-09-continuous-scales}

The `tmap::tm_scale_continuous()` function is used for continuous data. In case of variables with a skewed distribution, you can also use its variants – `tmap::tm_scale_continuous_log()` and `tm_scale_continuous_log1p()`. 

Generally there are two main groups of continuous color palettes: 

- **Sequential palettes**. These color palettes follow a gradient, for example from light to dark colors (light colors often tend to represent lower values), and are appropriate for continuous (numeric) variables. Sequential continuous palettes can be single ("brewer.blues" for example goes from light to dark blue, see @fig-cont-scale-nz left) or multi-color/hue ("yl_gn_bu" for example is a gradient from light yellow to blue via green, see @fig-cont-scale-nz middle). The difference in the legend is that there are no lower and upper limits of bins as can be seen in @fig-cont-scale-nz right. The right example uses the same color palette as the middle graph but this time segmented by bins. 

- **Diverging palettes**, typically range between three distinct colors (purple-white-green in @fig-cont-scale-nz) and are usually created by joining two single-color sequential palettes with the darker colors at each end. Their main purpose is to visualize the difference from an important reference point, e.g., a certain temperature, the median household income or the mean probability for a drought event. By default the midpoint values is set to 0 if negative and positive values are present. But the reference point’s value can be adjusted in {**tmap**} using the `midpoint` argument.



::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-09-continious-scale}
: Using a continuous scale
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### NZ

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-cont-scale-nz}
: Continuous scale of median income in New Zealand
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-cont-scale-nz
#| fig-cap: "Using a continuous map (left) instead of bins (middle, right) for displaying median income in New Zealand"
#| message: false # turn off resacle message


nz_1 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Median_income",
    fill.scale = tmap::tm_scale_continuous(
        values = "brewer.blues"
      )
  ) 

nz_2 <- tmap::tm_shape(nz) + 
  tmap::tm_polygons(
    fill = "Median_income", 
    fill.scale = tmap::tm_scale_continuous(
      values = "brewer.yl_gn_bu"
      )
    ) 

nz_3 <- tmap::tm_shape(nz) + 
  tmap::tm_polygons(
    fill = "Median_income", 
    fill.scale = tmap::tm_scale(
      values = "brewer.yl_gn_bu"
      )
    ) 

nz_4 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Median_income", 
    fill.scale = tmap::tm_scale_continuous(
      midpoint = 28000,
      values = "pu_gn_div"
      ) 
    ) +
  tmap::tm_credits("midpoint = 28,000", size = 0.7)

nz_5 <- tmap::tm_shape(nz) + 
  tmap::tm_polygons(
    fill = "Sex_ratio", 
    fill.scale = tmap::tm_scale_continuous(
      midpoint = 1.0000000,
      values = "pu_gn_div")
    ) +
  tmap::tm_credits("midpoint = 1.000000", size = 0.7)


tmap::tmap_arrange(nz_1, nz_2, nz_3, nz_4, nz_5)
```
***

The standard scale `tmap::tm_scale()` sets breaks automatically to create bins with a lower and upper limit (middle and right). In contrast `tmap::tm_scale_continuous()` (left) provides a continuum scale without bins and borders.

::::
:::::


###### WHR

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-cont-scale-whr}
: Cantril ladder values for countries mapped onto a continuous scale
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-cont-scale-whr
#| fig-asp: 0.6
#| fig-cap: "Using a continuous scale instead of setting breaks for bins to display the  Happiness ladder scores in the countries of the world"
#| 
tmap::tm_shape(world_no_ata) +
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = 
      tmap::tm_scale_continuous(
        values = "brewer.blues"
      ),
    fill.legend = tmap::tm_legend(
      orientation = "landscape",
      position = tmap::tm_pos_out("center", "bottom"),
      width = 50
    )
  )
      
```
***

Without `width = 50` the scale would be auto scaled. The width is calculated from the font size. With standard values `width = 50` is the maximum width without where no auto scaling is necessary. 
::::
:::::

:::

::::
:::::

#### Categorical scales {#sec-09-categorical-scales}

Categorical palettes consist of easily distinguishable colors and are most appropriate for categorical data without any particular order such as state names or land cover classes. Colors should be intuitive: rivers should be blue, for example, and pastures green. Avoid too many categories: maps with large legends and many colors can be uninterpretable.

::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-ID}
: Title for code collection
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### NZ

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-nz-cat}
: Using categorical scale for NZ parts
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-nz-cat
#| layout-ncol: 1
#| fig-cap: 
#|  - "Using categorical scales to distinguish north/south parts of New Zealand"
#|  - "Using categorical scales to distinguish regions of New Zealand"

tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Island",
    fill.scale = tmap::tm_scale_categorical(
        values = "brewer.accent"
      )
  ) 

tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Name",
    col = "MAP_COLORS",
    fill.scale = tmap::tm_scale_categorical(
        values = "poly.palette36"
      )
  ) + 
  tmap::tm_place_legends_right()


```

***

The regions in the lower graphics are difficult to distinguish because there are too many colors. I have used `col = "MAP_COLORS"` to create unique fill colors for adjacent regions. (A slightly improvement of the lower graphics would maybe if I ordered the items of the legend manually according to the position of the colored part.)

::::
:::::


###### Economy groups

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-world-economy-cat}
: Categorization of world economies
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-world-economy-cat
#| fig-cap: "Categorization of world economies"

tmap::tm_shape(world_no_ata) +
  tmap::tm_polygons(
    fill = "economy",
    fill.scale = tmap::tm_scale_categorical(
        values = "brewer.accent"
      ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_out("center", "bottom")
      ) 
  ) 

```

::::
:::::

###### Income groups

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-world-income-grp-cat}
: Income group categorization of world's countries
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-world-income-grp-cat
#| fig-cap: Income group categorization of world's countries"
#| fig-asp: 0.5

tmap::tm_shape(world_no_ata) +
  tmap::tm_polygons(
    fill = "income_grp",
    fill.scale = tmap::tm_scale_categorical(
        values = "brewer.accent"
      ),
    fill.legend = tmap::tm_legend(
        orientation = "landscape",
        position = tmap::tm_pos_out("center", "bottom"),
        width = 50
      )
  ) 
```

::::
:::::

:::

::::
:::::


#### Scale summary {#sec-09-scale-summary}

![Examples of categorical, sequential and diverging palettes.](img/09-colpal-examples.png){#fig-09-colpal-examples
fig-alt="Examples of categorical, sequential and diverging palettes." fig-align="center" 
width="80%"}


There are two important principles for consideration when working with colors: perceptibility and accessibility. Firstly, colors on maps should match our perception. This means that certain colors are viewed through our experience and also cultural lenses. For example, green colors usually represent vegetation or lowlands, and blue is connected with water or coolness. Color palettes should also be easy to understand to effectively convey information. It should be clear which values are lower and which are higher, and colors should change gradually. Secondly, changes in colors should be accessible to the largest number of people. Therefore, it is important to use colorblind friendly palettes as often as possible.


### Legends {#sec-09-legends}

After we decided on our visual variable and its properties, we should move our attention toward the related map legend style. Using the `tmap::tm_legend()` function, we may change its title, position, orientation, or even disable it. The most important argument in this function is title, which sets the title of the associated legend. In general, a map legend title should provide two pieces of information: what the legend represents and what the units are of the presented variable. The following code chunk demonstrates this functionality by providing a more attractive name than the variable name "Land_area" (note the use of `base::expression()` to create superscript text).

::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-09-customize-legends}
: Customizing legends
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### Title

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-legend-title}
: Changing the legend title
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: legend-title

legend_title = base::expression("Area (km"^2*")")

tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Land_area", 
    fill.legend = tmap::tm_legend(
      title = legend_title,
      orientation = "portrait",
      position = tmap::tm_pos_in("left", "top")
      )
    )
  
```

::::
:::::


###### Orientation / Position

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-legend-orientation-position}
: Customizing of the legend orientation and position
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: legend-orientation-position

tmap::tm_shape(nz) +
  tmap::tm_polygons(fill = "Land_area",
      fill.legend = tmap::tm_legend(
      title = legend_title,
      orientation = "portrait",
      position = tmap::tm_pos_in(
        pos.h = "left", 
        pos.v = "top"
        )
      )
  )
```

::::
:::::

:::

::::
:::::

The default legend orientation in {**tmap**} is "portrait", however, an alternative legend orientation, "landscape", is also possible. Other than that, we can also customize the location of the legend using the position argument.

The legend position (and also the position of several other map elements in tmap) can be customized using one of a few functions. (I have the relevant functions for oeintation and position already used in @sec-09-scales.) 

The two most important functions for the positions are:

- `tmap::tm_pos_out()`: the default, adds the legend outside of the map frame area. We can customize its location with two values that represent the horizontal position ("left", "center", or "right"), and the vertical position ("bottom", "center", or "top")
- `tmap::tm_pos_in()`: puts the legend inside of the map frame area. We may decide on its position using two arguments, where the first one can be "left", "center", or "right", and the second one can be "bottom", "center", or "top".

Alternatively, we may just provide a vector of two values (or two numbers between 0 and 1) here – and in such case, the legend will be put inside the map frame.

***


### Layouts {#sec-09-layouts}

The map layout refers to the combination of all map elements into a cohesive map. Map elements include among others 

- the objects to be mapped, 
- the map grid (`tmap::tm_graticules()`, `tmap::tm_grid()`), 
- the north arrow or compass (`tmap::tm_compass()`),
- the scale bar (`tmap::tm_scalebar()`), 
- the title (`tmap::tm_title()`), 
- the logo (`tmap::tm_logo()`),
- credits (`tmap::tm_credits()`), could also used for annotations, and 
- margins.

The color settings covered in the previous section relate to the palette and breakpoints used to affect how the map looks. Both may result in subtle changes that can have an equally large impact on the impression left by your maps.

#### Graticules and grid

::: {.callout-note}
###### Graticules versus Grid

- `tmap::tm_grid()` is used to draw grid lines based on the projection of the input data, e.g. its role is to represent the input data’s coordinates.
- `tm_graticules()` is used to draw lines of latitude (parallels) and longitude (meridians) in degrees, providing a geographic reference regardless of the data's projection.

See for details: [Grids and graticules in the tmap package](https://geocompx.org/post/2019/tmap-grid/)

:::

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-graticules-versus-grid}
: Difference between graticules and grid
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-graticules-versus-grid
#| fig-cap: "Using `tmap::tm_grid()` (left) and using `tmap::tm_graticules() with the degree sign (right)"

nz01 <- tmap::tm_shape(nz) + 
  tmap::tm_polygons() +
  tmap::tm_grid()

nz02 <- tmap::tm_shape(nz) + 
  tmap::tm_polygons() +
  tmap::tm_graticules()

tmap::tmap_arrange(nz01, nz02)
```

::::
:::::

#### Components

Components are non-spatial parts of the plots:

- the north arrow or compass (`tmap::tm_compass()`),
- the scale bar (`tmap::tm_scalebar()`), 
- the title (`tmap::tm_title()`), 
- the logo (`tmap::tm_logo()`),
- credits (`tmap::tm_credits()`), could also used for annotations, and 

See also: [tmap basics: components](https://r-tmap.github.io/tmap/articles/basics_components).


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-layout-components}
: Showing layout components
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-layout-components
#| fig-cap: "New Zealand map with additonal layout components: title, compass, scale bar, credits and logo"

tmap::tm_shape(nz) + 
  tmap::tm_polygons() +
  # tmap::tm_graticules() +
  tmap::tm_compass(type = "8star", position = c("left", "top")) +
  tmap::tm_scalebar(breaks = c(0, 100, 200), text.size = 1, position = c("left", "top")) +
  tmap::tm_title("New Zealand") +
  tmap::tm_logo(base::system.file("help", "figures", "logo.png", package = "tmap")) +
  tmap::tm_credits("Source: https://www.stats.govt.nz/")
```

::::
:::::

#### Layout settings

{**tmap**} also allows a wide variety of layout settings to be changed. To delve into the meaning of all this parameters call the appropriate help file with `?tmap::tm_layout`. The following huge list gives you a first impression of the many possible settings.  

```{r}
#| label: show-layout-args
base::args(tmap::tm_layout)
```


Some of the above list of arguments are used in the following graphics:

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-layout-settings}
: Examples for different arguments for layout settings
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-layout-settings
#| fig-cap: "Examples for different arguments for layout settings. Changing the overall scale of the map to `scale = 4` (left), setting the background color `bg.color = 'lightblue'` (center) and removing the border around the graph with `frame = FALSE`"

map_nz <- tmap::tm_shape(nz) + tmap::tm_polygons()

map_nz1 <- map_nz + tmap::tm_layout(scale = 4)
map_nz2 <- map_nz + tmap::tm_layout(bg.color = "lightblue")
map_nz3 <- map_nz + tmap::tm_layout(frame = FALSE)

tmap::tmap_arrange(map_nz1, map_nz2, map_nz3)
```

::::
:::::

A helpful function for designing a specific layout is `tmap::tmap_design_mode()`. When the so-called "design mode" is enabled, inner and outer margins, legend position, and aspect ratio are shown explicitly in plot mode. Also, information about aspect ratios is printed in the console. This function sets the global option `tmap.design.mode`. It can be used as toggle function without arguments.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-design-mode}
: Turning design mode on/off to check and change specific layout options
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-desing-mode
#| results: hold
#| fig-cap: "Turning on/off the design mode to check and change specific layout options."

tmap::tmap_design_mode()
map_nz
tmap::tmap_design_mode()
```

***

The desing mode is especially valuable if you want to change the aspect ratio to remove white space around the figure.
::::
:::::


:::::{.my-resource}
:::{.my-resource-header}
:::::: {#lem-09-layout-settings}
: Resources for changing layout settings in {**tmap**}
::::::
:::
::::{.my-resource-container}

- {**tmap**} [basics: layout](https://r-tmap.github.io/tmap/articles/basics_layout)
- {**tmap**} [advanced: margins and aspect ratio](https://r-tmap.github.io/tmap/articles/adv_margins)
- {**tmap**} [advanced: options](https://r-tmap.github.io/tmap/articles/adv_options)
::::
:::::

### Faceted maps {#sec-09-faceted-maps}

Faceted maps are composed of many maps arranged side-by-side, and sometimes stacked vertically. Facets enable the visualization of how spatial relationships change with respect to another variable, such as time. The changing populations of settlements, for example, can be represented in a faceted map with each panel representing the population at a particular moment in time.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-faceted-maps-urban-agglo}
: Faceted maps
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-faceted-maps-urban-agglo
#| fig-cap: "Faceted map showing the top 30 largest urban agglomerations from 1970 to 2030 based on population projections by the United Nations."

urb_1950_2035 <- spData::urban_agglomerations
world <- tmap::World

urb_1970_2030 <- urb_1950_2035 |> 
   dplyr::filter(year %in% c(1970, 1990, 2010, 2030))

tmap::tm_shape(world) +
  tmap::tm_polygons(fill = "white") +
  tmap::tm_shape(urb_1970_2030) +
  tmap::tm_symbols(
    fill = "red", 
    col = "black",
    size = "population_millions",
    size.legend = tmap::tm_legend(
      title = "Urban populations in million")
    ) +
  tmap::tm_facets_wrap(by = "year", nrow = 2) +
  tmap::tm_layout(
    legend.orientation = "landscape",
    legend.position = tmap::tm_pos_out(
      cell.h = "center",
      cell.v = "bottom"
    )
  )
  
```
***

::: {.callout-note}
###### How to change the legend title?

I just learned that the legend title has to be changed with the argument that calls the database column. In this case it is `size = "population_millions"`, therefore I had to use `size.legend = tmap::tm_legend()` (and not `size.legend = tmap::tm_legend()` as I tried all the time!)

Revising my notes I learned that the first paragraph in (@sec-09-scales) stated exactly this procedure: But `fill.scale`, `size.scale` does not only control how the selected visual variable is presented but also the legend title.

:::

::::
:::::

The preceding code chunk demonstrates key features of faceted maps created using the `tmap::tm_facets_wrap()` function:

- Shapes that do not have a facet variable are repeated (countries in world in this case)
- The `by` argument which varies depending on a variable ("year" in this case)
- The `nrow/ncol` setting specifying the number of rows and columns that facets should be arranged into

Alternatively, it is possible to use the `tmap::tm_facets_grid()` function that allows to have facets based on up to three different variables: one for rows, one for columns, and possibly one for pages.

In addition to their utility for showing changing spatial relationships, faceted maps are also useful as the foundation for animated maps (see @sec-09-animated-maps).

### Inset maps (empty) {#sec-09-inset-maps}

An inset map is a smaller map rendered within or next to the main map. It could serve many different purposes, including providing a context or bringing some non-contiguous regions closer to ease their comparison. They could be also used to focus on a smaller area in more detail or to cover the same area as the map, but representing a different topic.

## Animated maps {#sec-09-animated-maps}

### Introduction

Faceted maps, described in Section (@sec-09-faceted-maps), can show how spatial distributions of variables change (e.g., over time), but the approach has disadvantages. Facets become tiny when there are many of them. Furthermore, the fact that each facet is physically separated on the screen or page means that subtle differences between facets can be hard to detect.

Animated maps solve these issues. Although they depend on digital publication, this is becoming less of an issue as more and more content moves online. Animated maps can still enhance paper reports: you can always link readers to a webpage containing an animated (or interactive) version of a printed map to help make it come alive.

### Comparing downloads

There are several animation packages, including {**tmap**} which includes with `tmap::tmap_animation()` a specialized function for geospatial animations.

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-ID-text}
: Comparing downloads of several animation packages
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: download-numbers-animation-packages

my_pkgs_dl(
  pkgs = c(
    "tmap", 
    "gganimate", 
    "plotly", 
    "animation", 
    "animint2", 
    "loon", 
    "tweenR"),
  period = "last-month", 
  days = 30
)
```

***

I have no much experience with animations packages. But it is evident for me that the first three are very important:

- {**plotly**): I have already started to learn {**plotly**} and produced some [personal notes](https://bookdown.org/pbaumgartner/learning-plotly/). I think I will use it to get more information out of map graphics via interactivity, for instance moving the cursor over the map and showing the name of the country and/or some vital statistics.
- {**gganimate**} is important because it is fully compatible with {**ggplot2**} and it can be used for specifying transitions and animations in a flexible and extensible way. But at the moment (2025-05-22)
 I do not have any experience with this package.


::::
:::::

Here I will concentrate on {**tmap**}.

### Ladder score

Instead of reproducing the book's example, I will try to use the `r glossary("WHR")` dataset. I want to see the changes over time for the `r glossary("cantril ladder")` score of the countries. My main question is: What does an animation of the well-being scores looks like and is it valuable graphical representation to understand the data better?

As a tempalte for my own code I am going to use the animated map showing the [top 30 largest urban agglomerations from 1950 to 2030](https://github.com/geocompx/geocompr/blob/main/code/09-urban-animation.R) based on population projects by the United Nations. 



:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-faceted-maps-for-animation}
: Producing faceted maps for the animation
::::::
:::
::::{.my-r-code-container}

<center>**Run this code chunk manually if the file still needs to be downloaded.**</center>

```{r}
#| label: faceted-maps-world-whr
#| eval: false

whr_2011_2024 <- base::readRDS("data/chapter09/whr_final.rds") |> 
  dplyr::filter(wb_group_name == "World") |> 
  dplyr::select(1:3, 6)

world_map_countries <- base::readRDS("data/chapter09/world_map2.rds") |> 
  tibble::as_tibble() |> 
  sf::st_as_sf() |> 
  dplyr::rename(iso3 = adm0_a3, name = admin) |> 
  dplyr::select(iso3, name)

my_save_data_file("chapter09", world_map_countries, "world_map_countries.rds")

world_whr_2011_2024 <- 
  dplyr::left_join(
    whr_2011_2024,
    world_map_countries,
    dplyr::join_by(iso3 == iso3)
  ) |> 
  sf::st_as_sf()

m_save <- tmap::tm_shape(world_whr_2011_2024) +
  tmap::tm_polygons(
    fill = "ladder_score", 
    col = "black",
    fill.scale = tmap::tm_scale(
       values = "matplotlib.rainbow"
       ),
    fill.legend = tmap::tm_legend(title = "Well-being Score"),
    fill.free = FALSE
    ) +
  tmap::tm_facets_wrap(by = "year", nrow = 1, ncol = 1, free.coords = FALSE) +
  tmap::tm_layout(
    legend.orientation = "landscape",
    legend.position = tmap::tm_pos_out("center", "bottom")
  ) 

tmap::tmap_animation(
  tm = m_save, 
  filename = "data/chapter09/ladder_score.gif",
  width = 1200, 
  height = 800,
  delay = 800,
  asp = 1.8,
  outer.margins = 0)


```

***

<center>(*For this R code chunk is no output available*)</center>

::::
:::::

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-run-animation}
: Run the animation
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-run-animation
#| fig-cap: "Show well-being country scores over the years 2011-2024 (2013 is missing). Higher values are higher happiness."

magick::image_read("data/chapter09/ladder_score.gif")
```

***

Wait some time for seeing the first change. I have set `delay = 800` to provide time for inspecting each year. But even with this long time the result is not very satisfying: It is difficult to get a better understanding about the trends. What I would need is to choose when to change to get which year and this option combined with the interactive inspection of data by hovering the mouse pointer over the map.
::::
:::::

## Interactive maps {#sec-09-interactive-maps}

### Introduction

We will explore how to make slippy maps with {**tmap**} (the syntax of which we have already learned), {**mapview**}, {**mapdeck**} and finally with the very popular {**leaflet**} (which provides low-level control over interactive maps and has many supporting packages).

:::::{.my-resource}
:::{.my-resource-header}
:::::: {#lem-09-leaflet-ecosphere}
: Leaflet and packages extending its function (Leaflet ecosphere)
::::::
:::
::::{.my-resource-container}
I just learned that there are many packages that extend the functionality of {**leafelet**}. In alphabetical order:

- {**leafem**}: {**leaflet**} extension for {**mapview**}
- {**leafgl**}: High-performance 'WebGL' rendering for {**leaflet**}
- {**leaflegend**}: Add custom legends to {**leaflet**} maps
- {**leaflet**}: Create interactive web maps with the JavaScript 'leaflet' library
- {**leaflet.extras**}: Extra functionality for {**leaflet**}
- {**leaflet.providers**}: Leaflet providers
- {**leafpop**}: Include tables, images and graphs in {**leaflet**} pop-ups
- {**leafsync**}: Small multiples (facets) for {**leaflet**} web maps


::::
:::::

### Preparing data


:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-prepare-leaflet-data}
: Prepare data for calling leaflet WHR 2024 data
::::::
:::
::::{.my-r-code-container}

<center>**Run this code chunk manually if the file still needs to be downloaded.**</center>

```{r}
#| label: whr-2024-tmap-view
#| eval: false

whr_2024 <- base::readRDS("data/chapter09/whr_final.rds") |> 
  dplyr::filter(
    wb_group_name == "World" & year == 2024) |> 
  dplyr::select(1:3, 6)

world_map_countries <- base::readRDS("data/chapter09/world_map_countries.rds")  

world_whr_2024 <- 
  dplyr::left_join(
    whr_2024,
    world_map_countries,
    dplyr::join_by(iso3 == iso3)
  ) |> 
  sf::st_as_sf()

leaflet_whr_2024 <- tmap::tm_shape(world_whr_2024) + 
  tmap::tm_polygons(
    fill = "ladder_score", 
    id = "name", 
    hover = TRUE,
    fill.scale = tmap::tm_scale(
       values = "matplotlib.rainbow",
       value.na = "yellow")
     )

my_save_data_file("chapter09", leaflet_whr_2024, "leaflet_whr_2024.rds")

```

***

<center>(*For this R code chunk is no output available*)</center>

Hovering about the menu "paper pile" you can choose the kind of background map. The background labels appear whenever there are no data for countries and the map is resized to greater details. But my specific yellow color does not work for NA's countries as they all appear with a gray background.
::::
:::::

### Applying {**leaflet**} via {**tmap**}

A unique feature of {**tmap**} is its ability to create static and interactive maps using the same code. Maps can be viewed interactively at any point by switching to view mode, using the command `tmap::tmap_mode("view")`. This should be the same as `tmap::tmap_leaflet(data, show  = TRUE)` with the advantage that you can specify to show or hide the map and that you don't need to place the code to return to plot mode with `tmap::tmap_mode("plot")`. 

::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-09-apply-leaflet}
: Apply {leaflet} via {tmap} with appropriate parameters
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### Standard Map WHR 2024

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-apply-leaflet-via-tmap}
: Map of well-being scores in 2024
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-leaflet-via-tmap
#| message: false
#| results: hold
#| fig-cap: "Interactive map of the well-being data in 2024"

leaflet_whr_2024 <- base::readRDS("data/chapter09/leaflet_whr_2024.rds")

tmap::tmap_mode("view")
leaflet_whr_2024
tmap::tmap_mode("plot")
```
***

The function `tmap::tmap_leaflet(leaflet_whr_2024, show = TRUE)` did not work.


::::
:::::



###### Base map WHR 2024

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-basemap-whr-2024}
: Interactive map with specified base map
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-interactive-with-basemap
#| message: false
#| results: hold
#| fig-cap: "Interactive map with specified base map 'Esri.WorldGrayCanvas'"

tmap::tmap_mode("view")
leaflet_whr_2024 + tmap::tm_basemap(server = "Esri.WorldGrayCanvas")
tmap::tmap_mode("plot")
```

***

There are many options to choose a provider for the `server` parameter. Choose one from the [leaflet provider preview](https://leaflet-extras.github.io/leaflet-providers/preview/).
::::
:::::

###### Facets 2011 & 2024

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-sync-facet}
: Compare 2011 with 2024 WHR data
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-sync-leaflet-facets
#| fig-cap: "Compare 2011 with 2024 WHR data of world's countries"
#| message: false
#| results: hold

whr_final <- base::readRDS("data/chapter09/whr_final.rds") 
world_map_countries <- base::readRDS("data/chapter09/world_map_countries.rds") 


whr_2011.2024 <- whr_final |> 
  dplyr::filter(
    wb_group_name == "World" & (year == 2011 | year == 2024)
    ) |> 
  dplyr::select(1,2,6) |> 
  tidyr::pivot_wider(
    names_from = year,
    values_from = ladder_score
  )

world_whr_2011.2024 <- 
  dplyr::left_join(
    whr_2011.2024,
    world_map_countries,
    dplyr::join_by(iso3 == iso3)
  ) |> 
  sf::st_as_sf()


tmap::tmap_mode("view")
tmap::tm_shape(world_whr_2011.2024) + 
  tmap::tm_polygons(c("2011", "2024"),
        palette = "matplotlib.rainbow",
        fill.legend = tmap::tm_legend(
        legend.title = c("Score", "Score")
        ),
        fill.free = FALSE
  ) +
  tmap::tm_facets_vstack(nrow = 1, sync = TRUE)
tmap::tmap_mode("plot")
```

***

There are two issues with these facets:

1. The legend for 2024 is called 2011. (Maybe I should change to a neutral scale title? But how?)
2. Synchronization only works with the lower graphics.
3. The breaks aren't optimal. For instance Russia has improved considerable from 5.284 in 2011 to 5.945, but you can't see this progress because both values are between 5 to 6. Here I should consider more sensible breaks. 



::::
:::::


:::

::::
:::::






