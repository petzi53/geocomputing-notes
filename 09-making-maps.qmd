---
execute:
  cache: false
  echo: true
  code-fold: true
---

# Making Maps with R {#sec-chap09}

```{r}
#| label: setup
#| results: hold
#| include: false

base::source(file = "R/helper.R")
ggplot2::theme_set(ggplot2::theme_bw())

```

## Table of content for chapter 09 {.unnumbered}

:::::: {#obj-chap03}
::::: my-objectives
::: my-objectives-header
Chapter section list
:::

::: my-objectives-container
TEXT
:::
:::::
::::::

## Introduction

I am following here Chapter 9 [Making Maps with
R](https://r.geocompx.org/adv-map), explaining mainly the use of
{**tmap**}. In addition to the example and code demonstrations I will
also use my own `r glossary("WHR")` dataset.

To facilitate working with the WHR dataset I have joined the ladder
score values in a new column "WHR" with the `world` dataset of
{**tmap**} and stored as `world_whr.rds` in "data/Chapter9"

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-join-world-whr-dataset}
: Join WHR ladder scores with {**tmap**} World dataset
:::
::::

::: my-r-code-container
```{r}
#| label: join-world-whr-dataset

my_create_folder("data/chapter09")

whr_2024 <-  base::readRDS("data/chapter09/whr_final_2024.rds") |> 
    dplyr::select(iso3, ladder_score) |> 
    dplyr::rename(WHR = ladder_score)

World <- tmap::World

world_whr <- dplyr::left_join(
    World,
    whr_2024,
    dplyr::join_by(iso_a3 == iso3)
)

my_save_data_file("chapter09", world_whr, "world_whr.rds")

dplyr::glimpse(world_whr)
```
:::
::::::

## Static maps

### {tmap} basics

:::::::::::::::::::: my-code-collection
::::: my-code-collection-header
::: my-code-collection-icon
:::

::: {#exm-09-tmap-basics}
: {**tmap**} basics
:::
:::::

:::::::::::::::: my-code-collection-container
::::::::::::::: panel-tabset
###### nz layers

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-nz-layers}
: New Zealand Layers
:::
::::

::: my-r-code-container
```{r}
#| label: fig-nz-layers
#| fig-cap: "New Zealand’s shape plotted with fill (left), border (middle) and fill and border (right) layers added using tmap functions."

# get nz data
nz <- spData::nz

# Add fill layer to nz shape
nz1 <- tmap::tm_shape(nz) +
  tmap::tm_fill() 
# Add border layer to nz shape
nz2 <- tmap::tm_shape(nz) +
  tmap::tm_borders() 
# Add fill and border layers to nz shape
nz3 <- tmap::tm_shape(nz) +
  tmap::tm_fill() +
  tmap::tm_borders()
  
tmap::tmap_arrange(nz1, nz2, nz3)
    

```
:::
::::::

###### whr world

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-world-with-layers}
: World countries layers
:::
::::

::: my-r-code-container
```{r}
#| label: fig-whr-world-with-layers
#| fig-asp: 0.5
#| echo: fenced 
#| fig-cap: "Shape of world countries plotted with fill and border layers added using tmap functions."


world_whr <- base::readRDS("data/chapter09/world_whr.rds")

(
    world_map <- world_whr |> 
        tmap::tm_shape() +
        tmap::tm_fill() +
        tmap::tm_borders() +
        tmap::tm_crs("+proj=robin")
)    
```
:::
::::::

###### Ladder scores

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-whr-ladder-scores}
: Numbered R Code Title
:::
::::

::: my-r-code-container
```{r}
#| label: fig-whr-ladder-scores
#| fig-asp: 0.4
#| echo: fenced 
#| fig-cap: "World Happiness Report Ladder scores"

(
    whr_map <- # works better with Antarctica and earth_boundary = TRUE
        tmap::tm_shape(world_whr) +
        tmap::tm_polygons("WHR") +
        tmap::tm_crs("+proj=robin") +
        # tmap::tm_title("World Happiness") +
        tmap::tm_layout(
            earth_boundary = FALSE, 
            frame = FALSE
            )
)
```
:::
::::::
:::::::::::::::
::::::::::::::::
::::::::::::::::::::

### Map objects

Map objects can be stored as class `tmap` into the R memory. You can add
new shapes later with `+ tm_shape(new_obj)`

(The book example are not useful for my applications as it add raster
objects and uses geometry operations.)

### Visual variables

The plots in the previous section demonstrate tmap’s default aesthetic
settings. Gray shades are used for `tmap::tm_fill()` layers and a
continuous black line is used to represent lines created with
`tmap::tm_borders()`. Of course, these default values and other
aesthetics can be overridden.

-   `fill`: fill color of a polygon
-   `col`: color of a polygon border, line, point, or raster
-   `lwd`: line width
-   `lty`: line type
-   `size`: size of a symbol
-   `shape`: shape of a symbol

Additionally, you may customize the fill and border color transparency
using `fill_alpha` and `col_alpha`.

#### Fixed values

:::::::::::::::: my-code-collection
::::: my-code-collection-header
::: my-code-collection-icon
:::

::: {#exm-09-visualize-fixed-values}
: Visualize fixed aesthetic arguments on different layer types
:::
:::::

:::::::::::: my-code-collection-container
::::::::::: panel-tabset
###### New Zealand

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-visualize-fixed-nz-values}
: NZ: Visualize aesthetic arguments with fixed values
:::
::::

::: my-r-code-container
```{r}
#| label: fig-nz-visualize-values
#| fig-cap: "Impact of changing commonly used fill and border aesthetics to fixed values."

ma1 = tmap::tm_shape(nz) + tmap::tm_polygons(fill = "red")
ma2 = tmap::tm_shape(nz) + tmap::tm_polygons(fill = "red", fill_alpha = 0.3)
ma3 = tmap::tm_shape(nz) + tmap::tm_polygons(col = "blue")
ma4 = tmap::tm_shape(nz) + tmap::tm_polygons(lwd = 3)
ma5 = tmap::tm_shape(nz) + tmap::tm_polygons(lty = 2)
ma6 = tmap::tm_shape(nz) + tmap::tm_polygons(fill = "red", fill_alpha = 0.3,
                                 col = "blue", lwd = 3, lty = 2)
tmap::tmap_arrange(ma1, ma2, ma3, ma4, ma5, ma6)
```
:::
::::::

###### WHR

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-visualize-fixed-whr-values}
: WHR: Visualize aesthetic arguments with fixed values
:::
::::

::: my-r-code-container
```{r}
#| label: fig-whr-visualize-values
#| fig-cap: "Impact of changing commonly used fill and border aesthetics to fixed values."

wrld1 = tmap::tm_shape(world_whr) + tmap::tm_polygons(fill = "red")
wrld2 = tmap::tm_shape(world_whr) + tmap::tm_polygons(fill = "red", fill_alpha = 0.3)
wrld3 = tmap::tm_shape(world_whr) + tmap::tm_polygons(col = "blue")
wrld4 = tmap::tm_shape(world_whr) + tmap::tm_polygons(lwd = 3)
wrld5 = tmap::tm_shape(world_whr) + tmap::tm_polygons(lty = 2)
wrld6 = tmap::tm_shape(world_whr) + tmap::tm_polygons(fill = "red", fill_alpha = 0.3,
                                 col = "blue", lwd = 3, lty = 2)
tmap::tmap_arrange(wrld1, wrld2, wrld3, wrld4, wrld5, wrld6)
```
:::
::::::
:::::::::::
::::::::::::
::::::::::::::::

#### Variable values

Using variable values, e.g. values from a column of the dataset, is the essential technique to show colored country differences on a map. Other issues (choosing an appropriate color palette, adapting text and position of the legend etc.) are — seen from a general perspective — only details.

:::::::::::::::: my-code-collection
::::: my-code-collection-header
::: my-code-collection-icon
:::

::: {#exm-09-visualize-variable-values}
: Visualize variable aesthetic arguments on different layer types
:::
:::::

:::::::::::: my-code-collection-container
::::::::::: panel-tabset
###### New Zealand

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-visualize-nz-variables}
: NZ: Visualize aesthetic arguments with NZ variables
:::
::::

::: my-r-code-container
```{r}
#| label: fig-visualize-nz-variables
#| fig-cap: "Fill regions of New Zealand with values of column 'Land_area'"

tmap::tm_shape(nz) + tmap::tm_fill(fill = "Land_area")
```
:::
::::::

###### WHR

:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-visualize-whr-variables}
: WHR: Visualize aesthetic arguments with WHR variables
:::
::::

::: my-r-code-container
```{r}
#| label: fig-visualize-whr-variables
#| fig-cap: "Fill countires of the world with well-being values of HPI and WHR"

well_being_HPI <- tmap::tm_shape(world_whr) + tmap::tm_fill(fill = "well_being")
well_being_WHR <- tmap::tm_shape(world_whr) + tmap::tm_fill(fill = "WHR")

tmap::tmap_arrange(well_being_HPI, well_being_WHR)
```

***

If you compare the well-being index from the Happiness Planet Index (`r glossary("HPI")`) and from the World Happiness Reports (`r glossary("WHR")`) you can see that the results are very similar. But there are some differences: For instance in countries with missing values, or Mexico, Colombia and Argentina have higher values in the WHR index. To understand these differences I would have to dive deeper in the different construction of the indexes.



:::
::::::
:::::::::::
::::::::::::
::::::::::::::::

Each visual variable has three related additional arguments, with suffixes of `.scale`, `.legend`, and `.free`. For example, the `tmap::tm_fill()` function has arguments such as `fill`, `fill.scale`, `fill.legend`, and `fill.free`. 

- The `.scale` argument determines how the provided values are represented on the map and in the legend (@sec-09-scales),
- The `.legend` argument is used to customize the legend settings, such as its title, orientation, or position (@sec-09-legends)
- The `.free` argument is relevant only for maps with many facets to determine if each facet has the same or different scale and legend.

### Scales {#sec-09-scales}

#### Setting breaks

Scales control how the values are represented on the map and in the
legend, and they largely depend on the selected visual variable. For
example, when our visual variable is `fill`, then `fill.scale` controls
how the colors of spatial objects are related to the provided values;
and when our visual variable is `size`, then `size.scale` controls how
the sizes represent the provided values.

By default, the used scale is `tmap::tm_scale()`, which selects the
visual settings automatically given by the input data type (factor,
numeric, and integer).

Let’s see how the scales work by customizing polygons’ fill colors.
Color settings are an important part of map design – they can have a
major impact on how spatial variability is portrayed.
    


    
::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-ID}
: Different color settings and scales for income variable
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### NZ


:::::: my-r-code
:::: my-r-code-header
::: {#cnj-09-color-nz-settings}
: Different break settings and color palettes for NZ medium income
:::
::::

::: my-r-code-container
```{r}
#| label: fig-nz-breaks
#| fig-cap: "Break settings. The results show (from top left to bottom right): default settings (= 'pretty' breaks), manual breaks, n breaks, and the impact of changing the palette."

nz_scale1 <- tmap::tm_shape(nz) + tmap::tm_polygons(fill = "Median_income")
nz_scale2 <- tmap::tm_shape(nz) + tmap::tm_polygons(fill = "Median_income",
                        fill.scale = tmap::tm_scale(breaks = c(0, 30000, 40000, 50000)))
nz_scale3 <- tmap::tm_shape(nz) + tmap::tm_polygons(fill = "Median_income",
                           fill.scale = tmap::tm_scale(n = 10))
nz_scale4 <- tmap::tm_shape(nz) + tmap::tm_polygons(fill = "Median_income",
                           fill.scale = tmap::tm_scale(values = "brewer.bu_gn"))

tmap::tmap_arrange(
  nz_scale1,
  nz_scale2,
  nz_scale3,
  nz_scale4
)



```
***

This figure shows four ways of splitting the input data values into a set of intervals.

-   **Top left**: The default setting uses ‘pretty’ breaks, e.g., rounds breaks into whole numbers where possible and spaces them evenly.
-   **Top right**: `breaks` allows you to manually set the breaks
-   **Bottom right**: `n` sets the number of bins into which numeric variables are
    categorized
-   **Bottom left**: `values` defines the color scheme, for example,
    `brewer.bu_gn`


::: {.callout-warning}
###### {tmap} version 4 has new names for color palettes

The value for the example color scheme is in the book `BuGn`. But this value results into a warning:
    
> [cols4all] color palettes: use palettes from the R package {**cols4all**}. Run `cols4all::c4a_gui()` to explore them. The old palette name "BuGn" is named "brewer.bu_gn". 
>
> Multiple palettes called "bu_gn" found: "brewer.bu_gn", "matplotlib.bu_gn". The first one, "brewer.bu_gn", is returned.
    
{**cols4all**} is a new R package for selecting color palettes, with a special orientation to include palettes for people with color vision deficiency. 
:::

:::
::::::

###### Standard breaks

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-settings-pretty-breaks}
: GDP per capita with standard ‘pretty’ breaks
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-settings-pretty-breaks
#| fig-cap: "GDP per capita with standard ('pretty') breaks" 

world_no_ata <- world_whr |> 
  dplyr::filter(name != "Antarctica")

tmap::tm_shape(world_no_ata) + 
  tmap::tm_polygons(
    fill = "gdp_cap_est",
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "bottom")
      )
  )


```
***

Because of it extraordinary GDP per capita value (200,000 US $) I have removed the uninhabited Antarctica from the map. It has a population of only 4490 people, supposedly researchers working in this huge area.



::::
:::::

###### Manual breaks

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-settings-manual-breaks}
: GDP per capita with breaks defined
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-settings-manual-breaks
#| echo: fenced
#| fig-asp: 0.5
#| fig-cap: "GDP per capita with breaks defined" 


tmap::tm_shape(world_whr) + 
  tmap::tm_polygons(
      fill = "gdp_cap_est",
      fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      ),              
      fill.scale = tmap::tm_scale(
        breaks = c(0, 5000, 10000, 15000, 20000, 200000)
        )
      )

```
***

To differentiate better the lower end of the distribution I have chosen small interval breaks until 20,000 US\$ and put together all those countries that GDP per capita is higher than 20,000 US\$.

I contrast to the previous example I have additionally I have set the aspect ratio of the figure. (See the code chunk option `fig-asp: 0.5`.) This removes the white space above and below the figure.

::::
:::::

###### n breaks

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-settings-n-breaks}
: GDP per capita with number of breaks specified (n = 10)
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-settings-n-breaks
#| fig-asp: 0.7
#| fig-cap: "GDP per capita with a specified number of breaks (n = 10)" 

tmap::tm_shape(world_whr) + 
  tmap::tm_polygons(
     fill = "gdp_cap_est",
     fill.scale = tmap::tm_scale(n = 10),
     fill.legend = tmap::tm_legend(
        title = "Estimated GDP per capita", 
        orientation = "landscape")
     )
```
***

If the data would have missing values I had to choose another color palette or tho change the default color for `NA`s. Otherwise the standard gray color for missing values (`NA`s) would be difficult to distinguish from the color of the lowest break (0-20,000).
::::
:::::





###### Color palette

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-choose-color-palette}
: Choosing another color palette
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-color-palette
#| fig-cap: "Different color palette" 
#| fig-asp: 0.5


world_no_ata <- world_whr |> 
  dplyr::filter(name != "Antarctica")

tmap::tm_shape(world_no_ata) + 
  tmap::tm_polygons(fill = "gdp_cap_est",
     fill.scale = tmap::tm_scale(
       values = "matplotlib.rainbow"
       ),
     fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "bottom")
      )
 )
  
```
***

In this example I haven chosen a color palette with different colors instead of just the same color with different saturation. The `matplotlib.rainbow` palette is very helpful to visually distinguish differences in the countries. It is much better suited than the standard "blues" or other gradient scale versions.

In this example you can't see the only red country Luxembourg with over 100,000 \$ GDP per capita, because it is too small. But you will see a tiny orange spot in Europe. This is Switzerland the only country slightly over 80,000 \$ GDP per capita. You will get a sightly better view if you click on this last figure to get a larger image.

::: {.callout-important}
###### Choose the desired color palette with the interactive {**shiny**} website calling `cols4all::ca4_gui()` from the console.
:::

::::
:::::

:::

::::
:::::


::: {.callout-tip}
###### Arguments work for other types of visual variables too

All of the above arguments (`breaks`, `n`, and `values`) also work for other types of visual variables. For example, `values` expects a vector of colors or a palette name for `fill.scale` or `col.scale`, a vector of sizes for `size.scale`, or a vector of symbols for `shape.scale`.
:::

#### Interval scales

The `tmap::tm_scale_intervals()` function splits the input data values into a set of intervals. In addition to setting breaks manually, {**tmap**} allows users to specify algorithms to create breaks with the style argument automatically. The default is `tmap::tm_scale_intervals(style = "pretty")`, which rounds breaks into whole numbers where possible and spaces them evenly.

- **style = "pretty"**: default value, rounds breaks into whole numbers where possible and spaces them evenly.
- **style = "equal"**: divides input values into bins of equal range and is appropriate for variables with a uniform distribution (not recommended for variables with a skewed distribution as the resulting map may end up having little color diversity).
- **style = "quantile"**: ensures the same number of observations fall into each category (with the potential downside that bin ranges can vary widely).
- **style = "jenks"**: identifies groups of similar values in the data and maximizes the differences between categories.
- **style = "log10_pretty"**: a common logarithmic (the logarithm to base 10) version of the regular pretty style used for variables with a right-skewed distribution.

::: {.callout-note}
###### Origin of class interval computation

Although `style` is an argument of {**tmap**} functions, in fact it originates as an argument in `classInt::classIntervals()`. See the [help pages](https://r-spatial.github.io/classInt/reference/classIntervals.html) for {**classInt**) especially the article on [head/tail breaks](https://r-spatial.github.io/classInt/articles/headtailsR.html) (Pareto 80/20 rule).
:::


::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-09-setting-intervals}
: Setting intervals with algorithms via "styles"
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### NZ

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-nz-setting-intervals}
: Different interval scale methods using the `style` argument
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-nz-setting-intervals
#| fig-cap: "Different interval scale methods using the `style` argument"

tmap::tmap_options(
  legend.position = 
    tmap::tm_pos_in(pos.h = "left", pos.v = "top")
)


nz_int1 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(fill = "Median_income",
          fill.scale = tmap::tm_scale_intervals(style = "pretty")) +
  tmap::tm_credits('style = "pretty"', size = 1)

nz_int2 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(fill = "Median_income",
          fill.scale = tmap::tm_scale_intervals(style = "equal")) +
  tmap::tm_credits('style = "equal"', size = 1)

nz_int3 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(fill = "Median_income",
          fill.scale = tmap::tm_scale_intervals(style = "quantile")) +
  tmap::tm_credits('style = "quantile"', size = 1)

nz_int4 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(fill = "Median_income",
          fill.scale = tmap::tm_scale_intervals(style = "jenks")) +
  tmap::tm_credits('style = "jenks"', size = 1)

nz_int5 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Population",
    fill.scale = (
      tmap::tm_scale_intervals(
        style = "log10_pretty",
        values = "brewer.bu_pu"
        )
    ) 
  ) +
  tmap::tm_credits('style = \n"log10_pretty"', size = 1)


tmap::tmap_arrange(nz_int1, nz_int2, nz_int3, nz_int4, nz_int5)


```
***

Here I have added the interval style for each example as annotation. I couldn't find an annotation function, so I had used `tmap::tm_credits()`. 

Note also the different color palette in the last example (style = "log10_pretty"). I have called `cols4all::c4a_gui()` from the console, set the number of colors to 3 and looked for a palette with blue and this reddish color at the high end.
::::
:::::


###### pretty

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-pretty}
: Set interval scale using `style = "pretty"`
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-pretty
#| fig-cap: "Set interval scale for WHR ladder scores using the standard `style = 'pretty'`."
#| fig-asp: 0.5


tmap::tm_shape(world_whr) + 
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = tmap::tm_scale_intervals(
        style = "pretty",
        values = "matplotlib.rainbow"
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***

These are the standard intervals. The code line `fill.scale = tmap::tm_scale_intervals(style = "pretty")` wouldn't be necessary. It results in nice intervals from 1 to 8.

Choosing the "matplotlib.rainbow" color palette helps to distinguish the different categories. So you can see that the only two countries with a blueish color in Asia (Afghanistan) and in Africa (Sierra Leone). It is easy to see that Afghanistan is the most unhappiness country falling the worst category between 1 and 2 (value = 1.368), whereas Sierra Leone belongs to the somewhat better next category. Sierra Leone actually has a value of almost 3 (value = 2.998). This is the disadvantage of interval categories: Each country belongs to one category, but you can't see where they are positioned inside their categories.
::::
:::::

###### equal1

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-equal}
: Set interval scale using `style = "equal"`
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-equal
#| fig-cap: "Set interval scale for WHR ladder scores using `style = 'equal'`."
#| fig-asp: 0.5

tmap::tm_shape(world_whr) + 
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = tmap::tm_scale_intervals(
        style = "equal",
        values = "matplotlib.rainbow"
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***

Here we get categories with ugly boundaries. It does not have an advantage to the better to interpret "pretty" solution.
::::
:::::

###### equal12

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-equal-12-breaks}
: Set interval scale using `style = "equal"` with 12 breaks
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-12-breaks
#| fig-cap: "Set interval scale for WHR ladder scores using the `style = 'equal'` with 12 breaks."
#| fig-asp: 0.5

tmap::tm_shape(world_whr) + 
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = tmap::tm_scale_intervals(
        style = "equal",
        n = 12,
        values = "cols4all.friendly13"
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***

Again we have ugly boundaries for each category. But this time there is an advantage: The 12 categories give a more detailed picture, especially in the higher end of the `r glossary("cantril ladder")` scores.

But the set of interval is still not ideal: For instance the second worst category has no element in it and at the high end we have not enough differentiation.

The "cols4all.friendly13" scale has 13 different colors, but for me there are two colors a that hare difficult to distinguish. So I decided to go with just 12 colors.
::::
:::::

###### quantile

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-quantile}
: Set interval scale using `style = "quantile"` 
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-quantile
#| fig-cap: "Set interval scale for WHR ladder scores using `style = 'quantile'`."
#| fig-asp: 0.5

tmap::tm_shape(world_whr) + 
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = tmap::tm_scale_intervals(
        style = "quantile",
        values = "cols4all.friendly13"
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***
This set of intervals gives a good rough picture of the WHR results: We have just 5 categories for 140 countries with ladder scores. In each category are placed 28 countries. So can we for instance decide the relative position of each country:

| Label     | Color               |
|-----------|---------------------|
| worst     | red colored countries |
| bad       | ochre / dark yellow colored countries |
| middle    | blue colored countries |
| good      | dark green colored countries |
| excellent | violet / purple colored countries |

Sure this is a very coarse classification but it gives an idea about the distribution of the happiness index in the world.
::::
:::::

###### quantile12

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-quantile}
: Set interval scale using `style = "quantile"` with 12 breaks
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-quantile12
#| fig-cap: "Set interval scale for WHR ladder scores using `style = 'quantile'`."
#| fig-asp: 0.5

tmap::tm_shape(world_whr) + 
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = tmap::tm_scale_intervals(
        style = "quantile",
        values = "cols4all.friendly13",
        n = 12
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***

Because of the many colors the interpretation is not easy. But you get a good idea in which value regions are a concentration of countries. The two broad categories at both ends are necessary to get the same amount of countries as in the much thinner inner categories.
:::::
::::

###### log10 (pop)

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-whr-interval-scale-log10}
: Set interval scale using `style = "log10_pretty"` for country populations
:::
::::
::::{.my-r-code-container}
```{r}
#| label: fig-whr-interval-scale-log10
#| fig-cap: "Set interval scale for WHR ladder scores using `style = 'log10_pretty'` for country populations"
#| fig-asp: 0.5

tmap::tm_shape(world_whr) + 
  tmap::tm_polygons(
    fill = "pop_est",
    fill.scale = tmap::tm_scale_intervals(
        style = "log10_pretty",
        values = "cols4all.friendly13"
        ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      )
  )
```

***

This is not a sensible map. I think `style = 'log10_pretty'` is better suited for instance to show an individual income distribution where 1% of the people owns the overwhelming part of the wealth. Or other content with a similar very skewed distribution.


:::::
::::



:::

::::
:::::

#### Continuous scales

The `tmap::tm_scale_continuous()` function is used for continuous data. In case of variables with a skewed distribution, you can also use its variants – `tmap::tm_scale_continuous_log()` and `tm_scale_continuous_log1p()`. 

Generally there are two main groups of continuous color palettes: 

- **Sequential palettes**. These color palettes follow a gradient, for example from light to dark colors (light colors often tend to represent lower values), and are appropriate for continuous (numeric) variables. Sequential continuous palettes can be single ("brewer.blues" for example goes from light to dark blue, see @fig-cont-scale-nz left) or multi-color/hue ("yl_gn_bu" for example is a gradient from light yellow to blue via green, see @fig-cont-scale-nz middle). The difference in the legend is that there are no lower and upper limits of bins as can be seen in @fig-cont-scale-nz right. The right example uses the same color palette as the middle graph but this time segmented by bins. 

- **Diverging palettes**, typically range between three distinct colors (purple-white-green in @fig-cont-scale-nz) and are usually created by joining two single-color sequential palettes with the darker colors at each end. Their main purpose is to visualize the difference from an important reference point, e.g., a certain temperature, the median household income or the mean probability for a drought event. By default the midpoint values is set to 0 if negative and positive values are present. But the reference point’s value can be adjusted in {**tmap**} using the `midpoint` argument.



::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-09-continious-scale}
: Using a continuous scale
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### NZ

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-cont-scale-nz}
: Continuous scale of median income in New Zealand
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-cont-scale-nz
#| fig-cap: "Using a continuous map (left) instead of bins (middle, right) for displaying median income in New Zealand"
#| message: false # turn off resacle message


nz_1 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Median_income",
    fill.scale = tmap::tm_scale_continuous(
        values = "brewer.blues"
      )
  ) 

nz_2 <- tmap::tm_shape(nz) + 
  tmap::tm_polygons(
    fill = "Median_income", 
    fill.scale = tmap::tm_scale_continuous(
      values = "brewer.yl_gn_bu"
      )
    ) 

nz_3 <- tmap::tm_shape(nz) + 
  tmap::tm_polygons(
    fill = "Median_income", 
    fill.scale = tmap::tm_scale(
      values = "brewer.yl_gn_bu"
      )
    ) 

nz_4 <- tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Median_income", 
    fill.scale = tmap::tm_scale_continuous(
      midpoint = 28000,
      values = "pu_gn_div"
      ) 
    ) +
  tmap::tm_credits("midpoint = 28,000", size = 0.7)

nz_5 <- tmap::tm_shape(nz) + 
  tmap::tm_polygons(
    fill = "Sex_ratio", 
    fill.scale = tmap::tm_scale_continuous(
      midpoint = 1.0000000,
      values = "pu_gn_div")
    ) +
  tmap::tm_credits("midpoint = 1.000000", size = 0.7)


tmap::tmap_arrange(nz_1, nz_2, nz_3, nz_4, nz_5)
```
***

The standard scale `tmap::tm_scale()` sets breaks automatically to create bins with a lower and upper limit (middle and right). In contrast `tmap::tm_scale_continuous()` (left) provides a continuum scale without bins and borders.

::::
:::::


###### WHR

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-cont-scale-whr}
: Cantril ladder values for countries mapped onto a continuous scale
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-cont-scale-whr
#| fig-asp: 0.6
#| fig-cap: "Using a continuous scale instead of setting breaks for bins to display the  Happiness ladder scores in the countries of the world"
#| 
tmap::tm_shape(world_no_ata) +
  tmap::tm_polygons(
    fill = "WHR",
    fill.scale = 
      tmap::tm_scale_continuous(
        values = "brewer.blues"
      ),
    fill.legend = tmap::tm_legend(
      orientation = "landscape",
      position = tmap::tm_pos_out("center", "bottom"),
      width = 50
    )
  )
      
```
***

Without `width = 50` the scale would be auto scaled. The width is calculated from the font size. With standard values `width = 50` is the maximum width without where no auto scaling is necessary. 
::::
:::::

:::

::::
:::::

#### Categorical scales

Categorical palettes consist of easily distinguishable colors and are most appropriate for categorical data without any particular order such as state names or land cover classes. Colors should be intuitive: rivers should be blue, for example, and pastures green. Avoid too many categories: maps with large legends and many colors can be uninterpretable.

::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-ID}
: Title for code collection
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### NZ

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-nz-cat}
: Using categorical scale for NZ parts
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-nz-cat
#| layout-ncol: 1
#| fig-cap: 
#|  - "Using categorical scales to distinguish north/south parts of New Zealand"
#|  - "Using categorical scales to distinguish regions of New Zealand"

tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Island",
    fill.scale = tmap::tm_scale_categorical(
        values = "brewer.accent"
      )
  ) 

tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Name",
    col = "MAP_COLORS",
    fill.scale = tmap::tm_scale_categorical(
        values = "poly.palette36"
      )
  ) + 
  tmap::tm_place_legends_right()


```

***

The regions in the lower graphics are difficult to distinguish because there are too many colors. I have used `col = "MAP_COLORS"` to create unique fill colors for adjacent regions. (A slightly improvement of the lower graphics would maybe if I ordered the items of the legend manually according to the position of the colored part.)

::::
:::::


###### Economy groups

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-world-economy-cat}
: Categorization of world economies
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-world-economy-cat
#| fig-cap: "Categorization of world economies"

tmap::tm_shape(world_no_ata) +
  tmap::tm_polygons(
    fill = "economy",
    fill.scale = tmap::tm_scale_categorical(
        values = "brewer.accent"
      ),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_out("center", "bottom")
      ) 
  ) 

```

::::
:::::

###### Income groups

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-world-income-grp-cat}
: Income group categorization of world's countries
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-world-income-grp-cat
#| fig-cap: Income group categorization of world's countries"
#| fig-asp: 0.5

tmap::tm_shape(world_no_ata) +
  tmap::tm_polygons(
    fill = "income_grp",
    fill.scale = tmap::tm_scale_categorical(
        values = "brewer.accent"
      ),
    fill.legend = tmap::tm_legend(
        orientation = "landscape",
        position = tmap::tm_pos_out("center", "bottom"),
        width = 50
      )
  ) 
```

::::
:::::

:::

::::
:::::


#### Summary

![Examples of categorical, sequential and diverging palettes.](img/09-colpal-examples.png){#fig-09-colpal-examples
fig-alt="Examples of categorical, sequential and diverging palettes." fig-align="center" 
width="80%"}


There are two important principles for consideration when working with colors: perceptibility and accessibility. Firstly, colors on maps should match our perception. This means that certain colors are viewed through our experience and also cultural lenses. For example, green colors usually represent vegetation or lowlands, and blue is connected with water or coolness. Color palettes should also be easy to understand to effectively convey information. It should be clear which values are lower and which are higher, and colors should change gradually. Secondly, changes in colors should be accessible to the largest number of people. Therefore, it is important to use colorblind friendly palettes as often as possible.


### Legends {#sec-09-legends}

After we decided on our visual variable and its properties, we should move our attention toward the related map legend style. Using the tm_legend() function, we may change its title, position, orientation, or even disable it. The most important argument in this function is title, which sets the title of the associated legend. In general, a map legend title should provide two pieces of information: what the legend represents and what the units are of the presented variable. The following code chunk demonstrates this functionality by providing a more attractive name than the variable name Land_area (note the use of expression() to create superscript text):

::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-09-customize-legends}
: Customizing legends
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### Title

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-legend-title}
: Changing the legend title
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: legend-title

legend_title = base::expression("Area (km"^2*")")

tmap::tm_shape(nz) +
  tmap::tm_polygons(
    fill = "Land_area", 
    fill.legend = tmap::tm_legend(
      title = legend_title,
      orientation = "portrait",
      position = tmap::tm_pos_in("left", "top")
      )
    )
  
```

::::
:::::


###### Orientation / Position

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-legend-orientation-position}
: Customizing of the legend orientation and position
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: legend-orientation-position

tmap::tm_shape(nz) +
  tmap::tm_polygons(fill = "Land_area",
      fill.legend = tmap::tm_legend(
      title = legend_title,
      orientation = "portrait",
      position = tmap::tm_pos_in(
        pos.h = "left", 
        pos.v = "top"
        )
      )
  )
```

::::
:::::

:::

::::
:::::

The default legend orientation in {**tmap**} is "portrait", however, an alternative legend orientation, "landscape", is also possible. Other than that, we can also customize the location of the legend using the position argument.

The legend position (and also the position of several other map elements in tmap) can be customized using one of a few functions. (I have the relevant functions for oeintation and position already used in @sec-09-scales.) 

The two most important functions for the positions are:

- `tmap::tm_pos_out()`: the default, adds the legend outside of the map frame area. We can customize its location with two values that represent the horizontal position ("left", "center", or "right"), and the vertical position ("bottom", "center", or "top")
- `tmap::tm_pos_in()`: puts the legend inside of the map frame area. We may decide on its position using two arguments, where the first one can be "left", "center", or "right", and the second one can be "bottom", "center", or "top".

Alternatively, we may just provide a vector of two values (or two numbers between 0 and 1) here – and in such case, the legend will be put inside the map frame.

***


### Layouts {#sec-09-layouts}


## Experiments (unfinished)
:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-09-color-setting-whr-ladder-scores}
: Special color settings for WHR ladder scores 
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: fig-color-setting-whr-ladder-scores
#| fig-cap: "Choosing specialized color paletted to notice visually better different WHR ladder scores. Additionally I have changed the color for `NA`s. Top: Using `matplotlib.rainbow` scale. Bottom: Using the standard `blues` scale."
#| layout-ncol: 1


tmap::tmap_mode("view")
wld_whr1 <- tmap::tm_shape(world_whr) + 
  tmap::tm_polygons(
    fill = "WHR", 
    id = "name", 
    hover = TRUE,
    fill.scale = tmap::tm_scale(
       values = "matplotlib.rainbow",
       value.na = "yellow")
     )

wld_whr2 <- tmap::tm_shape(world_whr) + 
  tmap::tm_polygons(fill = "WHR",
     fill.scale = tmap::tm_scale(
       value.na = "yellow")
     ) 

tmap::tmap_arrange(wld_whr1, wld_whr2)

tmap::tmap_mode("plot")
```

***

The `matplotlib.rainbow` palette is very helpful to distinguish the differences. It is much better than the standard "blues" version.


::::
:::::







::: {.my-code-collection}
:::: {.my-code-collection-header}
::::: {.my-code-collection-icon}
:::::
:::::: {#exm-ID}
: Title for code collection
::::::

::::

::::{.my-code-collection-container}

::: {.panel-tabset}

###### header1

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-code-name-a}
: Numbered R Code Title (Original)
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: text-ax
#| eval: false

# tmap::tmap_design_mode()

World <- tmap::World
tmap::tm_shape(World) + 
  tmap::tm_crs("auto") +
  tmap::tm_polygons(
    fill = "HPI",
    fill.scale = tmap::tm_scale(value.na = "yellow"),
    fill.legend = tmap::tm_legend(
        position = tmap::tm_pos_in("left", "center")
      ) 
  ) 
  
# tmap::tm_layout(asp = 1.62) 


tmap::tmap_options_reset()
tmap::tmap_options(
  legend.position = tmap::tm_pos_in(pos.h = "left", pos.v = "center"),
  "value.na" = list(fill = "yellow"),
  "component.autoscale" = FALSE
 )
lobstr::tree(tmap::tmap_options_diff())

tmap::tmap_options_save("my_style")
tmap::tmap_style("my_style")


World <- tmap::World
tmap::tm_shape(World) +
  tmap::tm_crs("auto") +
  tmap::tm_polygons(
    fill = "HPI",
    fill.scale = tm_scale(),
    fill.legend = tm_legend()
    )



# nz_median +
#   tmap::tm_polygons(
#     fill = "Median_income", 
#     fill.scale = tmap::tm_scale_intervals(style = "pretty")
#     ) 
#   
# 
# nz_int1 <- tmap::tm_shape(nz) + 
#   tmap::tm_polygons(fill = "Median_income",
#           fill.scale = tmap::tm_scale_intervals(style = "pretty")) +
#   tmap::tm_options(component.autoscale = FALSE)
# 
# nz_int2 <- tmap::tm_shape(nz) + 
#   tmap::tm_polygons(fill = "Median_income",
#           fill.scale = tmap::tm_scale_intervals(style = "equal"))+
#   tmap::tm_options(component.autoscale = FALSE)
# 
# nz_int3 <- tmap::tm_shape(nz) + 
#   tmap::tm_polygons(fill = "Median_income",
#           fill.scale = tmap::tm_scale_intervals(style = "quantile")) +
#   tmap::tm_options(component.autoscale = FALSE)
# 
# nz_int4 <- tmap::tm_shape(nz) + 
#   tmap::tm_polygons(fill = "Median_income",
#           fill.scale = tmap::tm_scale_intervals(style = "jenks")) +
#   tmap::tm_options(component.autoscale = FALSE)
# 
# nz_int5 <- tmap::tm_shape(nz) + 
#   tmap::tm_polygons(fill = "Population",
#           fill.scale = tmap::tm_scale_intervals(style = "log10_pretty")) +
#   tmap::tm_options(component.autoscale = FALSE)
# 
# tmap::tmap_arrange(nz_int1, nz_int2, nz_int3, nz_int4, nz_int5)


# # a fancy set of options:
# tmap::tmap_options(
#   bg.color = "steelblue",
#   outer.bg.color = "salmon",
#   frame.color = "purple3",
#   frame.lwd = 5,
#   compass.type = "8star",
#   legend.bg.color = "gold",
#   legend.position = tm_pos_in(pos.h = "left", pos.v = "top")
#  )


```

::::
:::::


###### header2

:::::{.my-r-code}
:::{.my-r-code-header}
:::::: {#cnj-code-name-b}
: Numbered R Code Title (Tidyverse)
::::::
:::
::::{.my-r-code-container}
```{r}
#| label: text-by
#| eval: false

1 + 1
```

::::
:::::

:::

::::
:::::

